<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>2023面试题前端三剑客遇上chatGPT | 前端攻城狮ZhuoRu</title><meta name="keywords" content="张卓如,chatGPT,前端"><meta name="author" content="ZhuoRu"><meta name="copyright" content="ZhuoRu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="baidu-site-verification" content="code-0ABMo98myg"><meta property="og:type" content="article">
<meta property="og:title" content="2023面试题前端三剑客遇上chatGPT">
<meta property="og:url" content="https://webzhuoru.github.io/post/230702.html">
<meta property="og:site_name" content="前端攻城狮ZhuoRu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://webzhuoru.github.io/img/tab2.png">
<meta property="article:published_time" content="2023-07-16T16:15:20.585Z">
<meta property="article:modified_time" content="2023-07-16T16:18:57.363Z">
<meta property="article:author" content="ZhuoRu">
<meta property="article:tag" content="web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://webzhuoru.github.io/img/tab2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://webzhuoru.github.io/post/230702"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZhuoRu","link":"链接: ","source":"来源: 前端攻城狮ZhuoRu","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-17 00:18:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/css/function.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://thirdqq.qlogo.cn/g?b=sdk&amp;nk=2276839311&amp;s=140" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span></a></div><div class="menus_item"><a class="site-page" href="/sponsorWall/"><i class="fa-fw fas fa-images"></i><span> 赞助墙</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/other/"><i class="fa-fw fas fa-coffee"></i><span> Demo</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/tab2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">前端攻城狮ZhuoRu</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span></a></div><div class="menus_item"><a class="site-page" href="/sponsorWall/"><i class="fa-fw fas fa-images"></i><span> 赞助墙</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/other/"><i class="fa-fw fas fa-coffee"></i><span> Demo</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2023面试题前端三剑客遇上chatGPT</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-16T16:15:20.585Z" title="发表于 2023-07-17 00:15:20">2023-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-16T16:18:57.363Z" title="更新于 2023-07-17 00:18:57">2023-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-chatGPT/">面试题 chatGPT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2023面试题前端三剑客遇上chatGPT"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前端高频面试题-2023版"><a href="#前端高频面试题-2023版" class="headerlink" title="前端高频面试题 - 2023版"></a>前端高频面试题 - 2023版</h1><h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML + CSS"></a>HTML + CSS</h2><h4 id="1-、什么是-BFC-如何触发-有何特点-如何解决-margin”塌陷”"><a href="#1-、什么是-BFC-如何触发-有何特点-如何解决-margin”塌陷”" class="headerlink" title="1 、什么是 BFC ?如何触发? 有何特点? 如何解决 margin”塌陷”?"></a>1 、什么是 BFC ?如何触发? 有何特点? 如何解决 margin”塌陷”?</h4><p>BFC是块级格式化上下文的缩写，是一种页面渲染的方式。</p>
<p>BFC可以理解为一个独立的渲染区域，其中的元素布局不会影响到外部元素。</p>
<p>BFC的触发条件包括：根元素、浮动元素、绝对定位元素、display属性为inline-block、table-cell、table-caption、flex、grid等元素，以及overflow属性不为visible的元素。</p>
<p>BFC的特点包括：可以防止margin塌陷、可以清除浮动、可以自适应两栏布局等。</p>
<p>解决margin塌陷的方法包括：将元素放入一个新的BFC中、使用padding代替margin、使用border代替margin等。</p>
<h3 id="2、CSS-如何处理溢出-说一下-overflow-不同值的区别"><a href="#2、CSS-如何处理溢出-说一下-overflow-不同值的区别" class="headerlink" title="2、CSS 如何处理溢出? 说一下 overflow 不同值的区别"></a>2、CSS 如何处理溢出? 说一下 overflow 不同值的区别</h3><p>CSS如何处理溢出：</p>
<p>CSS中可以使用overflow属性来处理溢出。当一个元素的内容超出了其容器的大小时，overflow属性可以控制溢出内容的显示方式。</p>
<p>overflow不同值的区别：</p>
<ol>
<li><p>visible：默认值，不会裁剪内容，溢出的内容会显示在容器外部。</p>
</li>
<li><p>hidden：裁剪溢出的内容，不显示在容器外部。</p>
</li>
<li><p>scroll：显示滚动条，可以滚动查看溢出的内容。</p>
</li>
<li><p>auto：自动显示滚动条，只有当内容溢出时才会显示滚动条。</p>
</li>
<li><p>inherit：继承父元素的overflow属性值。</p>
</li>
</ol>
<p>总之，overflow属性可以控制元素内容的溢出方式，根据实际需求选择不同的值来达到最佳效果。</p>
<h3 id="3、三栏布局有什么实现方式"><a href="#3、三栏布局有什么实现方式" class="headerlink" title="3、三栏布局有什么实现方式?"></a>3、三栏布局有什么实现方式?</h3><p>三栏布局有多种实现方式，以下是其中几种：</p>
<ol>
<li><p>浮动布局：将左右两栏浮动，中间栏设置 margin 或 padding，需要注意清除浮动。</p>
</li>
<li><p>绝对定位布局：将左右两栏绝对定位，中间栏设置 margin 或 padding，需要注意父元素设置相对定位。</p>
</li>
<li><p>flex 布局：将父元素设置为 flex 容器，左右两栏设置为固定宽度，中间栏设置为 flex-grow: 1。</p>
</li>
<li><p>grid 布局：将父元素设置为 grid 容器，左右两栏设置为固定宽度，中间栏设置为 grid-column: 2 / -2。</p>
</li>
</ol>
<p>以上是常见的三栏布局实现方式，具体选择哪种方式取决于具体需求和兼容性要求。</p>
<h3 id="4、css-calc-属性作用是什么-主要用于解决什么问题"><a href="#4、css-calc-属性作用是什么-主要用于解决什么问题" class="headerlink" title="4、css calc 属性作用是什么? 主要用于解决什么问题?"></a>4、css calc 属性作用是什么? 主要用于解决什么问题?</h3><p>CSS calc属性可以让我们在CSS中使用数学表达式来计算属性值，从而更加灵活地控制布局。它主要用于解决一些复杂布局的问题，例如在响应式设计中，我们需要根据屏幕宽度来计算元素的宽度，或者在实现等高布局时，我们需要计算元素的高度以保证它们的高度相等。使用calc属性可以让我们更加方便地实现这些复杂的布局需求。</p>
<h3 id="5、有一个固定长宽div，怎么实现在屏幕上垂直水平居中"><a href="#5、有一个固定长宽div，怎么实现在屏幕上垂直水平居中" class="headerlink" title="5、有一个固定长宽div，怎么实现在屏幕上垂直水平居中"></a>5、有一个固定长宽div，怎么实现在屏幕上垂直水平居中</h3><p>这是一个常见的前端面试题，解决方法如下：</p>
<ol>
<li>使用flex布局</li>
</ol>
<p>将父元素设置为flex布局，然后使用justify-content和align-items属性分别设置水平和垂直居中。</p>
<ol>
<li>使用绝对定位</li>
</ol>
<p>将父元素设置为相对定位，然后将子元素设置为绝对定位，并使用top、left、bottom、right属性分别设置距离父元素四个方向的距离为50%。同时，使用transform属性将子元素向上向左移动自身宽高的一半。translate(-50%, -50%);</p>
<ol>
<li>使用grid布局</li>
</ol>
<p>将父元素设置为grid布局，然后使用place-items属性分别设置水平和垂直居中。</p>
<h3 id="6、描述一下渐进增强-progressive-enhancement-和优雅降级-graceful-degradation"><a href="#6、描述一下渐进增强-progressive-enhancement-和优雅降级-graceful-degradation" class="headerlink" title="6、描述一下渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation)"></a>6、描述一下渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation)</h3><p>渐进增强是一种设计理念，它强调在开发网站或应用程序时，应该首先关注基本功能和核心内容，然后逐步添加更高级的功能和增强效果，以确保在不同设备和浏览器上都能够提供最基本的用户体验。</p>
<p>优雅降级是一种设计理念，它强调在开发网站或应用程序时，应该首先考虑最高级别的功能和效果，然后逐步降低到更基本的功能和效果，以确保在旧版本的浏览器或设备上也能够提供相对较好的用户体验。这种方法通常需要使用特定的技术和代码，以确保在不支持某些功能或效果的浏览器上也能够正常运行。</p>
<h3 id="7、iframe-有哪些优点-哪些缺点-用它来解决过什么问题"><a href="#7、iframe-有哪些优点-哪些缺点-用它来解决过什么问题" class="headerlink" title="7、iframe 有哪些优点? 哪些缺点? 用它来解决过什么问题?"></a>7、iframe 有哪些优点? 哪些缺点? 用它来解决过什么问题?</h3><p>Iframe是一种HTML标签，它可以在一个网页中嵌入另一个网页。它的优点包括：</p>
<ol>
<li><p>可以将一个大的网页分成多个小的网页进行加载，从而提高网页的加载速度和性能。</p>
</li>
<li><p>可以实现跨域通信，使得不同域名下的网页可以进行数据交互。</p>
</li>
<li><p>可以实现网页的动态加载，使得网页内容可以根据用户的操作进行实时更新。</p>
</li>
</ol>
<p>Iframe的缺点包括：</p>
<ol>
<li><p>可能会导致网页的加载速度变慢，因为每个Iframe都需要单独加载。</p>
</li>
<li><p>可能会导致网页的安全性问题，因为Iframe可以用于跨域攻击。</p>
</li>
<li><p>可能会导致网页的可访问性问题，因为Iframe中的内容可能无法被搜索引擎索引。</p>
</li>
</ol>
<p>Iframe可以用来解决一些问题，例如：</p>
<ol>
<li><p>可以用来实现网页的异步加载，从而提高网页的性能和用户体验。</p>
</li>
<li><p>可以用来实现网页的动态更新，从而使得网页内容可以根据用户的操作进行实时更新。</p>
</li>
<li><p>可以用来实现网页的跨域通信，从而使得不同域名下的网页可以进行数据交互。</p>
</li>
</ol>
<h3 id="8、Google-Chrome-如何支持大小小于-12px-的文字"><a href="#8、Google-Chrome-如何支持大小小于-12px-的文字" class="headerlink" title="8、Google Chrome 如何支持大小小于 12px 的文字?"></a>8、Google Chrome 如何支持大小小于 12px 的文字?</h3><p>Google Chrome 支持大小小于 12px 的文字的方法是使用 CSS 属性 <code>-webkit-text-size-adjust</code>，将其设置为 <code>none</code>，即可禁用 Chrome 的默认文本大小调整。这样可以确保小字体的清晰度和可读性。但需要注意的是，这个属性只在 WebKit 内核的浏览器中有效，其他浏览器需要使用不同的方法来支持小字体。</p>
<h3 id="9、描述一下-css-盒子模型"><a href="#9、描述一下-css-盒子模型" class="headerlink" title="9、描述一下 css 盒子模型"></a>9、描述一下 css 盒子模型</h3><p>CSS 盒子模型是指在网页中，每个 HTML 元素都被看作是一个矩形的盒子，这个盒子包含了元素的内容、内边距、边框和外边距。盒子模型可以通过 CSS 的属性来控制元素的大小、边距、内边距和边框等样式。</p>
<p>盒子模型分为两种：标准盒子模型和怪异盒子模型。</p>
<p>标准盒子模型的宽度和高度只包括内容的宽度和高度，</p>
<p>而怪异盒子模型的宽度和高度包括了内容、内边距和边框的宽度和高度。</p>
<h3 id="10、HTML5的特性有哪些"><a href="#10、HTML5的特性有哪些" class="headerlink" title="10、HTML5的特性有哪些?"></a>10、HTML5的特性有哪些?</h3><p>HTML5的新特性包括但不限于以下几个方面：</p>
<ol>
<li><p>语义化标签：HTML5新增了一些语义化标签，如header、footer、nav、article、section等，使得页面结构更加清晰明了。</p>
</li>
<li><p>视频和音频：HTML5支持直接在网页中播放视频和音频，不需要使用Flash等插件。</p>
</li>
<li><p>Canvas绘图：HTML5的Canvas标签可以用来绘制2D图形和动画效果，使得网页的交互性更加丰富。</p>
</li>
<li><p>本地存储：HTML5提供了localStorage和sessionStorage两种本地存储方式，可以在浏览器端存储数据，方便离线使用和数据传输。</p>
</li>
<li><p>Web Workers：HTML5的Web Workers可以在后台运行JavaScript代码，提高了网页的性能和响应速度。</p>
</li>
<li><p>Web Socket：HTML5的Web Socket可以实现浏览器和服务器之间的实时通信，使得网页的交互性更加强大。</p>
</li>
<li><p>Geolocation：HTML5的Geolocation可以获取用户的地理位置信息，方便网页根据用户位置提供更加个性化的服务。</p>
</li>
<li><p>表单控件：HTML5新增了一些表单控件，如date、time、email、url等，使得表单的输入更加方便和准确。</p>
</li>
</ol>
<p>总之，HTML5的新特性使得网页的交互性、性能和用户体验都得到了很大的提升。</p>
<h3 id="11、CSS3-的特性有哪些"><a href="#11、CSS3-的特性有哪些" class="headerlink" title="11、CSS3 的特性有哪些?"></a>11、CSS3 的特性有哪些?</h3><p>CSS3 的特性包括但不限于以下几点：</p>
<ol>
<li>新的选择器，如属性选择器、伪类选择器、伪元素选择器等；</li>
<li>盒子模型的改进，包括盒子阴影、圆角、边框图片、背景图片等；</li>
<li>文字效果的增强，如文字阴影、文字渐变、文字描边等；</li>
<li>变形效果，如旋转、缩放、倾斜、移动等；</li>
<li>过渡和动画效果，如渐变、旋转、缩放、移动等；</li>
<li>媒体查询，可以根据设备的不同来应用不同的样式；</li>
<li>弹性盒子布局，可以更方便地实现自适应布局；</li>
<li>网格布局，可以更方便地实现复杂的网页布局。</li>
</ol>
<p>这些特性的出现，大大提高了 CSS 的灵活性和可扩展性，使得前端开发更加高效和便捷。</p>
<h3 id="12、如何实现水平居中"><a href="#12、如何实现水平居中" class="headerlink" title="12、如何实现水平居中?"></a>12、如何实现水平居中?</h3><p>有多种方法可以实现水平居中，以下是几种常见的方式：</p>
<ol>
<li><p>使用文本对齐（text-align）属性：对于块级元素，将其父元素的text-align属性设置为”center”可以实现水平居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用margin属性：将要居中的元素的左右外边距（margin-left和margin-right）设置为”auto”，可以使其在父元素中水平居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Flexbox布局：将父元素的display属性设置为”flex”，并且设置justify-content属性为”center”，可以使所有子元素在父元素中水平居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Grid布局：将父元素的display属性设置为”grid”，并使用grid-template-columns属性设置列的宽度为自动和1fr，可以使子元素自动居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些方法适用于不同的布局需求和场景，你可以根据具体的情况选择最合适的方法来实现水平居中效果。</p>
<h3 id="13、如何实现垂直居中"><a href="#13、如何实现垂直居中" class="headerlink" title="13、如何实现垂直居中?"></a>13、如何实现垂直居中?</h3><p>实现垂直居中比水平居中稍微复杂一些，以下是几种常见的方法：</p>
<ol>
<li><p>使用Flexbox布局：将父元素的display属性设置为”flex”，并设置align-items属性为”center”，可以使所有子元素在父元素中垂直居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用绝对定位和transform属性：将要居中的元素的position属性设置为”absolute”，然后将top和left属性设置为50%，并且使用transform属性将元素向上移动自身高度的一半。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用表格布局：将父元素的display属性设置为”table”，并将子元素的display属性设置为”table-cell”和vertical-align属性设置为”middle”，可以实现垂直居中。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123; <span class="attribute">display</span>: table-cell; <span class="attribute">vertical-align</span>: middle;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些方法可以根据具体的布局需求和场景进行选择和调整。注意，有时候垂直居中可能会受到其他因素的影响，如父元素高度、子元素高度等，请确保相关的元素和属性已经设置合适。</p>
<h3 id="14、如何实现双圣杯布局"><a href="#14、如何实现双圣杯布局" class="headerlink" title="14、如何实现双圣杯布局?"></a>14、如何实现双圣杯布局?</h3><p>双圣杯布局是一种常见的三栏布局，其中两个侧边栏宽度固定，而中间的主内容栏宽度自适应。以下是一种实现双圣杯布局的方法：</p>
<p>HTML结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left-sidebar&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 左侧边栏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right-sidebar&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 右侧边栏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>CSS样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 左侧边栏宽度 */</span></span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>; <span class="comment">/* 右侧边栏宽度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 主内容自适应宽度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-sidebar</span>, <span class="selector-class">.right-sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 左右侧边栏固定宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，使用flex布局将父容器（<code>.container</code>）设置为display: flex，并设置左右侧边栏（<code>.left-sidebar</code>和<code>.right-sidebar</code>）的固定宽度。中间的主内容栏（<code>.main-content</code>）利用<code>flex-grow: 1</code>使其宽度自适应填充剩余空间。</p>
<p>可以根据具体的需求调整容器宽度、侧边栏宽度和样式。此方法可适用于大多数现代浏览器，并且在响应式设计中也具备一定的灵活性。</p>
<h3 id="15、CSS中选择器的优先级"><a href="#15、CSS中选择器的优先级" class="headerlink" title="15、CSS中选择器的优先级?"></a>15、CSS中选择器的优先级?</h3><p>优先级的顺序可以简单概括为：内联样式 &gt; ID选择器 &gt; 类选择器/伪类选择器/属性选择器 &gt; 元素选择器/伪元素选择器 &gt; 通用选择器/子选择器/相邻兄弟选择器。</p>
<h3 id="16、CSS-权重如何计算"><a href="#16、CSS-权重如何计算" class="headerlink" title="16、CSS 权重如何计算?"></a>16、CSS 权重如何计算?</h3><p>CSS选择器的优先级是由权重来计算的。权重是一个数值，用于确定每个选择器在应用样式时的优先级顺序。CSS权重计算的规则如下：</p>
<ol>
<li><p>内联样式的权重为1000，它具有最高优先级。</p>
</li>
<li><p>ID选择器的权重为100，它比类选择器和属性选择器的权重更高。</p>
</li>
<li><p>类选择器、属性选择器和伪类选择器的权重都为10。</p>
</li>
<li><p>元素选择器和伪元素选择器的权重为1。</p>
</li>
</ol>
<h3 id="17、HTML5-input-元素-type-属性有哪些"><a href="#17、HTML5-input-元素-type-属性有哪些" class="headerlink" title="17、HTML5 input 元素 type 属性有哪些?"></a>17、HTML5 input 元素 type 属性有哪些?</h3><p>HTML5的<code>input</code>元素的<code>type</code>属性有以下常见的取值：</p>
<ol>
<li><p><code>text</code>：用于输入纯文本，默认类型。</p>
</li>
<li><p><code>password</code>：用于输入密码，输入内容会以圆点或星号进行屏蔽。</p>
</li>
<li><p><code>number</code>：用于输入数值。</p>
</li>
<li><p><code>email</code>：用于输入电子邮件地址，浏览器会对输入进行验证。</p>
</li>
<li><p><code>url</code>：用于输入URL地址，浏览器会对输入进行验证。</p>
</li>
<li><p><code>tel</code>：用于输入电话号码。</p>
</li>
<li><p><code>date</code>：用于输入日期。</p>
</li>
<li><p><code>time</code>：用于输入时间。</p>
</li>
<li><p><code>datetime-local</code>：用于输入日期和时间。</p>
</li>
<li><p><code>month</code>：用于输入年月。</p>
</li>
<li><p><code>week</code>：用于输入年周。</p>
</li>
<li><p><code>search</code>：用于输入搜索关键词。</p>
</li>
<li><p><code>color</code>：用于选择颜色。</p>
</li>
<li><p><code>range</code>：用于选择范围，比如音量大小。</p>
</li>
<li><p><code>file</code>：用于上传文件。</p>
</li>
</ol>
<p>除了以上列出的常见类型，HTML5的<code>input</code>元素还支持其他类型，如<code>checkbox</code>、<code>radio</code>、<code>submit</code>、<code>reset</code>等，用于特定的输入和表单交互需求。</p>
<h3 id="18、CSS-中哪些属性可继承，哪些不可以？"><a href="#18、CSS-中哪些属性可继承，哪些不可以？" class="headerlink" title="18、CSS 中哪些属性可继承，哪些不可以？"></a>18、CSS 中哪些属性可继承，哪些不可以？</h3><p>可继承属性：</p>
<ul>
<li><code>font</code>：包括<code>font-family</code>、<code>font-size</code>、<code>font-weight</code>等字体相关属性。</li>
<li><code>color</code>：文本颜色。</li>
<li><code>text</code>：包括<code>text-align</code>、<code>text-decoration</code>等文本相关属性。</li>
<li><code>line-height</code>：行高。</li>
<li><code>white-space</code>：空白处理。</li>
<li><code>cursor</code>：鼠标指针样式。</li>
<li><code>list-style</code>：列表样式。</li>
</ul>
<p>不可继承属性：</p>
<ul>
<li><code>margin</code>：外边距。</li>
<li><code>padding</code>：内边距。</li>
<li><code>border</code>：边框样式。</li>
<li><code>background</code>：背景样式。</li>
<li><code>width</code>、<code>height</code>：宽度和高度。</li>
<li><code>position</code>：定位方式。</li>
<li><code>display</code>：显示方式。</li>
</ul>
<p>需要注意的是，并非所有属性都严格分为可继承和不可继承两类。有一些属性的可继承性取决于具体的情况，例如<code>opacity</code>属性是不可继承的，但是透明度的效果会影响其子元素。</p>
<p>此外，通过使用<code>inherit</code>关键字，可以显式地指定某个属性的继承行为，即使它通常是不可继承的。</p>
<p>需要根据具体属性的特性来确定其是否可继承，可以参考CSS属性的文档以了解更详细的继承规则。</p>
<h3 id="19、CSS-单位中-px、em-和-rem-的区别-配合-font-size-如何计算-移动端适配方案"><a href="#19、CSS-单位中-px、em-和-rem-的区别-配合-font-size-如何计算-移动端适配方案" class="headerlink" title="19、CSS 单位中 px、em 和 rem 的区别? 配合 font-size 如何计算? (移动端适配方案)"></a>19、CSS 单位中 px、em 和 rem 的区别? 配合 font-size 如何计算? (移动端适配方案)</h3><p>在CSS中，px、em和rem是三种不同的单位。px是像素单位，它是相对于屏幕分辨率而言的，而em和rem是相对单位，它们是相对于父元素的字体大小而言的。em是相对于父元素的字体大小，而rem是相对于根元素的字体大小。</p>
<p>在移动端适配方案中，我们通常使用rem作为单位，因为它可以根据根元素的字体大小进行缩放，从而实现适配不同的屏幕尺寸。我们可以通过设置根元素的字体大小来控制整个页面的缩放比例，通常建议将根元素的字体大小设置为16px，这样1rem就等于16px。</p>
<p>在计算font-size时，我们可以使用rem作为单位，例如，如果我们想将一个元素的字体大小设置为20px，我们可以将其设置为1.25rem（20/16=1.25）。这样，无论在任何屏幕尺寸下，该元素的字体大小都将按照相同的比例进行缩放，从而实现适配不同的设备。</p>
<h3 id="20、如何画一条-0-5px-的线？"><a href="#20、如何画一条-0-5px-的线？" class="headerlink" title="20、如何画一条 0.5px 的线？"></a>20、如何画一条 0.5px 的线？</h3><p>在普通的屏幕上，无法直接画出 0.5px 的线，因为屏幕的物理像素只能显示整数像素。但是在 Retina 屏幕上，可以使用 scale 属性将 1px 的线缩小一半来模拟 0.5px 的线。在 CSS 中，可以使用 transform: scale(0.5) 和 -webkit-transform: scale(0.5) 来实现。在移动端适配方案中，可以使用 rem 单位来进行适配，根据不同的屏幕宽度设置不同的根字体大小，从而实现自适应布局。</p>
<h3 id="21、隐藏一个元素有哪些方法-display-none-与-visibility-hidden-与-opacity-0-之间的区别"><a href="#21、隐藏一个元素有哪些方法-display-none-与-visibility-hidden-与-opacity-0-之间的区别" class="headerlink" title="21、隐藏一个元素有哪些方法? display: none 与 visibility: hidden 与 opacity: 0 之间的区别?"></a>21、隐藏一个元素有哪些方法? display: none 与 visibility: hidden 与 opacity: 0 之间的区别?</h3><ul>
<li>display: none：完全隐藏元素，不占据空间，无法点击，不会触发任何事件。</li>
<li>visibility: hidden：元素仍然占据空间，只是不可见，无法点击，但会触发事件。</li>
<li>opacity: 0：元素仍然占据空间，不可见但可点击，会触发事件。</li>
</ul>
<h3 id="22、position-的值有哪些，分别有什么特点"><a href="#22、position-的值有哪些，分别有什么特点" class="headerlink" title="22、position 的值有哪些，分别有什么特点?"></a>22、position 的值有哪些，分别有什么特点?</h3><ol>
<li><p>static：默认值，元素按照文档流进行排列，不进行定位。</p>
</li>
<li><p>relative：相对定位，元素相对于其正常位置进行定位，不会影响其他元素的布局。</p>
</li>
<li><p>absolute：绝对定位，元素相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于 body 元素进行定位。</p>
</li>
<li><p>fixed：固定定位，元素相对于浏览器窗口进行定位，不随页面滚动而移动。</p>
</li>
<li><p>sticky：粘性定位，元素在跨越特定阈值前为相对定位，之后为固定定位。</p>
</li>
</ol>
<p>其中，relative、absolute、fixed 三种定位方式可以通过 top、right、bottom、left 属性来指定元素的具体位置。</p>
<h3 id="23、什么是浮动，浮动会引起什么问题，有何解决方案"><a href="#23、什么是浮动，浮动会引起什么问题，有何解决方案" class="headerlink" title="23、什么是浮动，浮动会引起什么问题，有何解决方案?"></a>23、什么是浮动，浮动会引起什么问题，有何解决方案?</h3><p>浮动是一种 CSS 布局方式，可以让元素脱离文档流并向左或向右浮动。浮动元素会引起父元素高度塌陷，导致布局混乱。解决方案包括清除浮动和使用 flex 布局。清除浮动可以通过在父元素末尾添加一个空的 div 元素并设置 clear 属性，或者使用伪元素 ::after 清除浮动。使用 flex 布局可以避免浮动带来的问题，同时也更加灵活和方便。</p>
<h3 id="24、line-height-和-height-的区别"><a href="#24、line-height-和-height-的区别" class="headerlink" title="24、line-height 和 height 的区别"></a>24、line-height 和 height 的区别</h3><p>line-height 是指行高，即行与行之间的距离，而 height 是指元素的高度。line-height 可以控制行内元素的垂直居中，而 height 只能控制元素的高度。当 line-height 大于 height 时，行内元素会在行框中垂直居中。</p>
<h3 id="25、设置一个元素的背景颜色，背景颜色会填充哪些区域"><a href="#25、设置一个元素的背景颜色，背景颜色会填充哪些区域" class="headerlink" title="25、设置一个元素的背景颜色，背景颜色会填充哪些区域?"></a>25、设置一个元素的背景颜色，背景颜色会填充哪些区域?</h3><p>设置一个元素的背景颜色，背景颜色会填充该元素的内容区域、内边距区域和边框区域，但不包括外边距区域。如果元素设置了透明度，背景颜色也会受到透明度的影响。</p>
<h2 id="26、inline-block、inline-和-block-的区别-为什么-img-是-inline-还可以设置宽高？"><a href="#26、inline-block、inline-和-block-的区别-为什么-img-是-inline-还可以设置宽高？" class="headerlink" title="26、inline-block、inline 和 block 的区别;为什么 img 是 inline 还可以设置宽高？"></a>26、inline-block、inline 和 block 的区别;为什么 img 是 inline 还可以设置宽高？</h2><p>inline-block、inline 和 block 是 CSS 中常见的三种盒子模型，它们的主要区别在于它们的布局方式和元素的排列方式。block 元素会独占一行，宽度默认为父元素的宽度，高度可以自动调整或者手动设置；inline 元素不会独占一行，宽度由内容撑开，高度由字体大小决定；inline-block 元素既可以像 inline 元素一样排列在一行，又可以像 block 元素一样设置宽高。</p>
<p>img 元素默认是 inline 元素，但是它可以设置宽高是因为它是替换元素，它的宽高是由图片本身的大小决定的，而不是由内容撑开。因此，即使设置了宽高，它也不会影响到其他元素的排列。</p>
<h3 id="27、什么是重绘-什么是回流-如何减少-如何让文档脱离文档流"><a href="#27、什么是重绘-什么是回流-如何减少-如何让文档脱离文档流" class="headerlink" title="27、什么是重绘? 什么是回流? 如何减少?如何让文档脱离文档流?"></a>27、什么是重绘? 什么是回流? 如何减少?如何让文档脱离文档流?</h3><p>重绘是指当元素样式改变时，浏览器需要重新绘制元素的内容，但是元素的几何属性并未改变。回流是指当元素的几何属性发生改变时，浏览器需要重新计算元素的几何属性和位置，并重新绘制元素的内容。</p>
<p>为了减少重绘和回流，可以采取以下措施：使用 CSS3 的 transform 和 opacity 属性代替 top 和 left 属性；使用 position: absolute 或 fixed 属性代替 float 属性；避免频繁操作样式，可以使用 class 切换代替直接操作样式；使用文档碎片来减少 DOM 操作次数。</p>
<p>要让文档脱离文档流，可以使用 position: absolute 或 fixed 属性，或者使用 float 属性。这样可以让元素不再占据文档流中的位置，从而避免影响其他元素的布局。</p>
<h3 id="28、box-sizing-的作用，如何使用"><a href="#28、box-sizing-的作用，如何使用" class="headerlink" title="28、box-sizing 的作用，如何使用?"></a>28、box-sizing 的作用，如何使用?</h3><p>box-sizing是CSS中的一个属性，用于控制元素的盒模型计算方式。默认情况下，元素的宽度和高度只包括内容区域，而不包括边框和内边距。而使用box-sizing属性可以改变这种计算方式，让元素的宽度和高度包括边框和内边距。</p>
<h3 id="29、如何实现清除浮动？"><a href="#29、如何实现清除浮动？" class="headerlink" title="29、如何实现清除浮动？"></a>29、如何实现清除浮动？</h3><p>清除浮动可以通过以下几种方式实现：</p>
<ol>
<li><p>使用空元素清除浮动，即在浮动元素后面添加一个空的块级元素，并设置 clear 属性为 both。</p>
</li>
<li><p>使用 overflow 属性清除浮动，即在浮动元素的父元素上设置 overflow 属性为 auto 或 hidden。</p>
</li>
<li><p>使用 clearfix 清除浮动，即在浮动元素的父元素上添加 clearfix 类，并在 CSS 中定义 clearfix 类的样式。</p>
</li>
<li><p>使用 flexbox 布局清除浮动，即在浮动元素的父元素上设置 display 属性为 flex 或 inline-flex。</p>
</li>
</ol>
<p>以上几种方式都可以有效地清除浮动，具体使用哪种方式取决于具体的情况和需求。</p>
<h3 id="30、css-动画如何实现"><a href="#30、css-动画如何实现" class="headerlink" title="30、css 动画如何实现"></a>30、css 动画如何实现</h3><p>CSS 动画可以通过以下几种方式实现：</p>
<ol>
<li><p>使用 transition 属性，设置需要过渡的属性和过渡时间，当属性值发生变化时，会自动过渡到新的值。</p>
</li>
<li><p>使用 keyframes 和 animation 属性，定义动画的关键帧和动画属性，然后将动画应用到元素上。</p>
</li>
<li><p>使用 transform 属性，通过改变元素的位置、大小、旋转等属性来实现动画效果。</p>
</li>
<li><p>使用 JavaScript 控制元素的样式，通过改变样式属性的值来实现动画效果。</p>
</li>
</ol>
<h3 id="31、如何实现在某个容器中居中的布局？"><a href="#31、如何实现在某个容器中居中的布局？" class="headerlink" title="31、如何实现在某个容器中居中的布局？"></a>31、如何实现在某个容器中居中的布局？</h3><p>要实现在某个容器中居中的布局，可以使用以下方法：</p>
<ol>
<li><p>使用 flex 布局，将容器设置为 display: flex;，并使用 justify-content 和 align-items 属性来实现水平和垂直居中。</p>
</li>
<li><p>使用绝对定位，将容器设置为 position: absolute;，并使用 top、bottom、left、right 属性来实现居中。</p>
</li>
<li><p>使用 margin 属性，将容器的上下左右 margin 设置为 auto，这样容器就会在父容器中水平和垂直居中。</p>
</li>
<li><p>使用 transform 属性，将容器设置为 position: absolute;，并使用 translate 属性来实现居中。</p>
</li>
</ol>
<p>以上方法都可以实现在某个容器中居中的布局，具体使用哪种方法取决于具体的情况和需求。</p>
<h3 id="32、如何改变一个-DOM-元素的字体颜色"><a href="#32、如何改变一个-DOM-元素的字体颜色" class="headerlink" title="32、如何改变一个 DOM 元素的字体颜色?"></a>32、如何改变一个 DOM 元素的字体颜色?</h3><p>可以使用 CSS 的 color 属性来改变一个 DOM 元素的字体颜色，例如：<br>    .element {  color: red;}</p>
<p>这将把类名为 “element” 的元素的字体颜色改为红色。也可以使用 JavaScript 来动态地改变元素的字体颜色，例如：<br>    const element = document.querySelector(‘.element’);element.style.color = ‘red’;</p>
<p>这将选中类名为 “element” 的元素并将其字体颜色改为红色。</p>
<h3 id="33、相对布局和绝对布局，position-relative-和-obsolute"><a href="#33、相对布局和绝对布局，position-relative-和-obsolute" class="headerlink" title="33、相对布局和绝对布局，position:relative 和 obsolute"></a>33、相对布局和绝对布局，position:relative 和 obsolute</h3><p>相对布局和绝对布局是 CSS 中的两种常见布局方式。其中，position:relative 和 position:absolute 是两个常用的 CSS 属性，用于实现相对布局和绝对布局。</p>
<p>position:relative 属性用于相对定位，它会使元素相对于其正常位置进行定位，但不会使元素脱离文档流。使用 position:relative 属性时，可以通过 top、bottom、left、right 属性来调整元素的位置。</p>
<p>position:absolute 属性用于绝对定位，它会使元素脱离文档流，并相对于最近的已定位祖先元素进行定位。如果没有已定位的祖先元素，则相对于文档的 body 元素进行定位。使用 position:absolute 属性时，也可以通过 top、bottom、left、right 属性来调整元素的位置。</p>
<p>相对布局和绝对布局在实际开发中都有广泛的应用，可以用于实现各种复杂的布局效果。</p>
<h3 id="34、什么是弹性盒子-flex-布局"><a href="#34、什么是弹性盒子-flex-布局" class="headerlink" title="34、什么是弹性盒子 flex 布局?"></a>34、什么是弹性盒子 flex 布局?</h3><p>弹性盒子布局（Flexbox）是一种用于在容器中进行布局的 CSS3 新特性。它通过将容器分配给子元素的空间来对齐和分布它们，从而使响应式设计更加容易。使用 flex 布局，可以轻松地实现水平和垂直居中、等高列布局等常见布局需求。在 flex 布局中，通过设置容器的 display 属性为 flex 或 inline-flex 来启用 flex 布局，然后通过设置容器和子元素的 flex 属性来控制布局。</p>
<h3 id="35、什么是-rem-布局"><a href="#35、什么是-rem-布局" class="headerlink" title="35、什么是 rem 布局?"></a>35、什么是 rem 布局?</h3><p>rem 是一种相对于根元素（即 html 元素）字体大小的单位，rem 布局是指使用 rem 作为布局单位来实现响应式布局。通过设置根元素的字体大小，可以实现整个页面的缩放，从而适应不同的屏幕尺寸。相比于传统的固定像素布局，rem 布局更加灵活，可以适应不同的设备和屏幕尺寸。</p>
<h3 id="36、less-和-scss-有什么区别"><a href="#36、less-和-scss-有什么区别" class="headerlink" title="36、less 和 scss 有什么区别?"></a>36、less 和 scss 有什么区别?</h3><p>less 和 scss 都是 CSS 预处理器，它们的主要区别在于语法的不同。less 使用类似 CSS 的语法，而 scss 则使用类似于编程语言的语法。scss 支持大括号、分号和变量，而 less 则不支持。此外，scss 还支持条件语句和循环语句等高级功能，而 less 则不支持。总的来说，scss 更加灵活和强大，但 less 更加简单易学。</p>
<h2 id="37、-before-和-after-中双冒号和单冒号的区别"><a href="#37、-before-和-after-中双冒号和单冒号的区别" class="headerlink" title="37、::before 和::after 中双冒号和单冒号的区别?"></a>37、::before 和::after 中双冒号和单冒号的区别?</h2><p>::before 和 ::after 是 CSS 伪元素，用于在元素的内容前或后插入内容。双冒号(::)和单冒号(:)都可以用来表示伪元素，但是在 CSS3 中规定，双冒号(::)用于表示伪元素，而单冒号(:)用于表示伪类。在 CSS2 中，双冒号和单冒号都可以用来表示伪元素。因此，为了兼容 CSS2，CSS3 中双冒号(::)和单冒号(:)都可以用来表示伪元素，但是建议使用双冒号(::)来表示伪元素。</p>
<h3 id="38、CSS3-新增伪类，以及伪元素"><a href="#38、CSS3-新增伪类，以及伪元素" class="headerlink" title="38、CSS3 新增伪类，以及伪元素?"></a>38、CSS3 新增伪类，以及伪元素?</h3><p>CSS3 新增的伪类有：:target、:not、:nth-child、:nth-last-child、:nth-of-type、:nth-last-of-type、:first-child、:last-child、:first-of-type、:last-of-type、:only-child、:only-of-type、:checked、:enabled、:disabled、:read-only、:read-write、:placeholder-shown、:default、:valid、:invalid、:in-range、:out-of-range、:required、:optional、:root、:empty、:fullscreen。</p>
<p>CSS3 新增的伪元素有：::before、::after、::first-letter、::first-line、::selection、::backdrop、::placeholder、::marker、::spelling-error、::grammar-error。其中，::before 和 ::after 用于在元素的前面或后面插入内容，::first-letter 和 ::first-line 用于选择元素的第一个字母或第一行，::selection 用于选择被用户选中的文本。</p>
<h3 id="39、响应式布局实现方案"><a href="#39、响应式布局实现方案" class="headerlink" title="39、响应式布局实现方案?"></a>39、响应式布局实现方案?</h3><p>响应式布局实现方案包括：</p>
<ol>
<li><p>媒体查询：通过设置不同的 CSS 样式来适应不同的屏幕尺寸和设备类型。</p>
</li>
<li><p>弹性网格布局：使用 flexbox 或者 grid 布局来实现弹性的网格布局，使得页面元素能够自适应不同的屏幕尺寸。</p>
</li>
<li><p>图片响应式布局：使用 max-width 属性来设置图片的最大宽度，使得图片能够自适应不同的屏幕尺寸。</p>
</li>
<li><p>视口单位：使用 vw、vh、vmin、vmax 等视口单位来设置元素的大小和位置，使得页面元素能够根据视口大小自适应。</p>
</li>
<li><p>CSS 框架：使用流行的 CSS 框架如 Bootstrap、Foundation 等，这些框架提供了响应式布局的组件和工具，可以快速实现响应式布局。</p>
</li>
</ol>
<h3 id="40、link-标签和-import-标签的区别"><a href="#40、link-标签和-import-标签的区别" class="headerlink" title="40、link 标签和 import 标签的区别?"></a>40、link 标签和 import 标签的区别?</h3><p>link 标签和 import 标签都可以用于引入外部资源，如 CSS 文件或其他 HTML 文件。它们的区别在于：</p>
<ol>
<li>link 标签可以引入 CSS 文件和其他资源文件，而 import 标签只能引入 HTML 文件。</li>
<li>link 标签在页面加载时同时加载，而 import 标签是在页面 DOM 加载完成后才加载。</li>
<li>link 标签可以通过 rel 属性指定资源文件的关系，如 stylesheet、icon 等，而 import 标签没有这个属性。</li>
<li>link 标签可以通过 media 属性指定样式表适用的设备类型，而 import 标签没有这个属性。</li>
</ol>
<p>因此，如果需要引入 CSS 文件，应该使用 link 标签；如果需要引入 HTML 文件，可以使用 import 标签。</p>
<h3 id="41、transition-和-animation-的区别"><a href="#41、transition-和-animation-的区别" class="headerlink" title="41、transition 和 animation 的区别?"></a>41、transition 和 animation 的区别?</h3><p>transition 和 animation 都是 CSS3 动画效果的实现方式，但它们有以下区别：</p>
<ol>
<li><p>transition 是指在元素从一种样式逐渐变为另一种样式时，添加过渡效果，可以控制过渡的时间、速度、延迟等属性。而 animation 是指通过关键帧来控制元素的动画效果，可以控制动画的播放次数、速度、延迟等属性。</p>
</li>
<li><p>transition 只能控制元素从一种状态到另一种状态的过渡效果，而 animation 可以实现更复杂的动画效果，如旋转、缩放、移动等。</p>
</li>
<li><p>transition 的触发是通过 CSS 属性的变化来触发的，而 animation 可以通过 JavaScript 控制触发。</p>
</li>
<li><p>transition 的兼容性更好，而 animation 在一些老版本的浏览器中可能会出现兼容性问题。</p>
</li>
</ol>
<p>因此，在实现不同的动画效果时，可以根据具体的需求选择使用 transition 或 animation。</p>
<h3 id="42、说一下块元素、行元素、置换元素"><a href="#42、说一下块元素、行元素、置换元素" class="headerlink" title="42、说一下块元素、行元素、置换元素"></a>42、说一下块元素、行元素、置换元素</h3><p>块元素、行元素和置换元素是 CSS 中常见的元素类型。</p>
<p>块元素通常用于页面布局，它们会在页面上独占一行，比如 div、p、h1 等。</p>
<p>行元素通常用于文本排版，它们会在一行内排列，比如 span、a、img 等。</p>
<p>置换元素是一种特殊的元素，它们的内容不是由文档源代码定义的，而是由浏览器根据元素的标签和属性来创建的。比如 img、input、video 等。</p>
<p>需要注意的是，CSS 中的 display 属性可以用来改变元素的类型，比如将块元素设置为行元素或置换元素。</p>
<h3 id="43、多行元素的文本省略号如何实现"><a href="#43、多行元素的文本省略号如何实现" class="headerlink" title="43、多行元素的文本省略号如何实现?"></a>43、多行元素的文本省略号如何实现?</h3><p>可以使用 CSS 属性 <code>text-overflow</code> 来实现多行文本的省略号，但是需要结合 <code>display</code> 和 <code>overflow</code> 属性一起使用。具体实现步骤如下：</p>
<ol>
<li>将元素设置为块级元素，可以使用 <code>display: block;</code> 或者 <code>display: inline-block;</code>；</li>
<li>设置元素的高度，可以使用 <code>height</code> 或者 <code>max-height</code> 属性；</li>
<li>将元素的文本溢出部分隐藏，可以使用 <code>overflow: hidden;</code>；</li>
<li>设置文本的省略号，可以使用 <code>text-overflow: ellipsis;</code>。</li>
</ol>
<p>需要注意的是，<code>text-overflow</code> 属性只在以下条件下生效：</p>
<ol>
<li>元素必须设置 <code>white-space: nowrap;</code>，即文本不能换行；</li>
<li>元素必须有固定的宽度，不能是自适应宽度；</li>
<li>元素不能是浮动元素或绝对定位元素。</li>
</ol>
<h3 id="44、Doctype-作用-严格模式与混杂模式如何区分-它们有何意义"><a href="#44、Doctype-作用-严格模式与混杂模式如何区分-它们有何意义" class="headerlink" title="44、Doctype 作用? 严格模式与混杂模式如何区分? 它们有何意义?"></a>44、Doctype 作用? 严格模式与混杂模式如何区分? 它们有何意义?</h3><p>Doctype 是文档类型声明，它的作用是告诉浏览器当前 HTML 文档使用的是哪种 HTML 或 XHTML 规范。严格模式和混杂模式是指浏览器解析 HTML 文档时采用的不同的渲染模式。严格模式是指浏览器按照 HTML 或 XHTML 规范的标准解析文档，而混杂模式则是指浏览器采用更宽松的解析方式。严格模式可以避免一些浏览器的兼容性问题，提高页面的渲染速度和性能。</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="1、javascript-的数据类型有哪些"><a href="#1、javascript-的数据类型有哪些" class="headerlink" title="1、javascript 的数据类型有哪些?"></a>1、javascript 的数据类型有哪些?</h3><p>JavaScript 的数据类型包括基本数据类型和引用数据类型。其中基本数据类型包括：数字（Number）、字符串（String）、布尔值（Boolean）、空（Null）、未定义（Undefined）；引用数据类型包括：对象（Object）、数组（Array）、函数（Function）等。</p>
<h4 id="2、javascript-有哪些引用类型"><a href="#2、javascript-有哪些引用类型" class="headerlink" title="2、javascript 有哪些引用类型?"></a>2、javascript 有哪些引用类型?</h4><ol>
<li>Object 对象类型</li>
<li>Array 数组类型</li>
<li>Date 日期类型</li>
<li>RegExp 正则表达式类型</li>
<li>Function 函数类型</li>
<li>Map、Set、WeakMap、WeakSet 集合类型</li>
<li>Promise 异步编程类型</li>
<li>Symbol 唯一标识类型</li>
</ol>
<h3 id="3、如何判断-javascript-的数据类型"><a href="#3、如何判断-javascript-的数据类型" class="headerlink" title="3、如何判断 javascript 的数据类型?"></a>3、如何判断 javascript 的数据类型?</h3><p>可以使用 typeof 运算符来判断 JavaScript 的数据类型，它返回一个字符串，表示操作数的数据类型。例如，typeof ‘hello’ 返回 ‘string’，typeof 123 返回 ‘number’，typeof true 返回 ‘boolean’，typeof undefined 返回 ‘undefined’，typeof null 返回 ‘object’，typeof {} 返回 ‘object’，typeof [] 返回 ‘object’，typeof function(){} 返回 ‘function’。需要注意的是，typeof null 返回 ‘object’ 是一个历史遗留问题。</p>
<h3 id="4、怎么判断两个对象相等-如何判断空对象"><a href="#4、怎么判断两个对象相等-如何判断空对象" class="headerlink" title="4、怎么判断两个对象相等?如何判断空对象?"></a>4、怎么判断两个对象相等?如何判断空对象?</h3><p>判断两个对象相等可以使用 <code>Object.is()</code> 方法，该方法会比较两个值是否相等，包括 <code>NaN</code> 和 <code>+0/-0</code> 的情况。判断空对象可以使用 <code>Object.keys()</code> 方法，该方法会返回对象的所有属性名组成的数组，如果数组长度为 0，则说明该对象为空对象。</p>
<h3 id="5、0-1-0-2-为什么不等于-0-3-解释原理"><a href="#5、0-1-0-2-为什么不等于-0-3-解释原理" class="headerlink" title="5、0.1 + 0.2 为什么不等于 0.3 ? (解释原理)"></a>5、0.1 + 0.2 为什么不等于 0.3 ? (解释原理)</h3><p>这是因为在 JavaScript 中，数字都是以 IEEE 754 标准的双精度浮点数来表示的。而在这种表示方法中，0.1 和 0.2 都无法被精确表示，它们会被近似为最接近它们的双精度浮点数。因此，0.1 + 0.2 的结果也是一个近似值，而不是精确的 0.3。这个问题可以通过使用 toFixed() 方法来解决，例如 (0.1 + 0.2).toFixed(1) 将返回字符串 “0.3”。</p>
<h3 id="6、强制类型转换、隐式类型转换分别是什么，列举场景说明"><a href="#6、强制类型转换、隐式类型转换分别是什么，列举场景说明" class="headerlink" title="6、强制类型转换、隐式类型转换分别是什么，列举场景说明."></a>6、强制类型转换、隐式类型转换分别是什么，列举场景说明.</h3><p>强制类型转换是指通过代码强制将一个数据类型转换为另一个数据类型，常见的有 Number()、String()、Boolean() 等函数。</p>
<p>隐式类型转换是指在代码执行过程中，由 JavaScript 引擎自动将一个数据类型转换为另一个数据类型，常见的有加号运算符、比较运算符等。</p>
<p>场景举例：</p>
<ol>
<li><p>强制类型转换：将字符串转换为数字，可以使用 Number() 函数，例如：Number(‘123’)，结果为 123。</p>
</li>
<li><p>隐式类型转换：在使用加号运算符时，如果其中一个操作数为字符串类型，那么另一个操作数也会被转换为字符串类型，例如：’1’ + 2，结果为 ‘12’。</p>
</li>
<li><p>强制类型转换：将布尔值转换为数字，可以使用 Number() 函数，例如：Number(true)，结果为 1。</p>
</li>
<li><p>隐式类型转换：在使用比较运算符时，如果两个操作数的数据类型不同，JavaScript 引擎会自动将它们转换为同一种数据类型再进行比较，例如：’1’ == 1，结果为 true。</p>
</li>
</ol>
<h3 id="7、创建函数的几种方式"><a href="#7、创建函数的几种方式" class="headerlink" title="7、创建函数的几种方式?"></a>7、创建函数的几种方式?</h3><p>创建函数的几种方式包括：</p>
<ol>
<li><p>函数声明：使用 function 关键字声明一个函数，可以在任何地方调用。</p>
</li>
<li><p>函数表达式：将一个函数赋值给一个变量或常量，可以通过变量或常量名调用。</p>
</li>
<li><p>匿名函数：没有函数名的函数，可以通过变量或常量名调用。</p>
</li>
<li><p>箭头函数：ES6 新增的一种函数声明方式，可以简化函数声明的语法，可以通过变量或常量名调用。</p>
</li>
<li><p>构造函数：使用 new 关键字创建一个函数，可以通过实例化后的对象调用。</p>
</li>
<li><p>方法：将一个函数作为对象的属性，可以通过对象名调用。</p>
</li>
<li><p>自执行函数：定义后立即执行的函数，可以通过函数名调用。</p>
</li>
</ol>
<h3 id="8、javascript-创建对象的几种方式"><a href="#8、javascript-创建对象的几种方式" class="headerlink" title="8、javascript 创建对象的几种方式?"></a>8、javascript 创建对象的几种方式?</h3><p>JavaScript 创建对象的几种方式包括：</p>
<ol>
<li><p>对象字面量：使用大括号 {} 来创建对象，可以直接在大括号中添加属性和方法。</p>
</li>
<li><p>构造函数：使用函数来定义对象的属性和方法，然后使用 new 关键字来创建对象。</p>
</li>
<li><p>Object.create() 方法：使用 Object.create() 方法可以创建一个新对象，并将其原型设置为现有对象。</p>
</li>
<li><p>ES6 的 class 关键字：使用 class 关键字可以定义一个类，然后使用 new 关键字来创建对象。</p>
</li>
<li><p>工厂函数：使用一个函数来创建并返回一个新对象，可以在函数中定义对象的属性和方法。</p>
</li>
</ol>
<p>以上这些方式都可以用来创建对象，每种方式都有其适用的场景和优缺点。</p>
<h3 id="9、列举宿主对象、内置对象、原生对象并说明其定义。"><a href="#9、列举宿主对象、内置对象、原生对象并说明其定义。" class="headerlink" title="9、列举宿主对象、内置对象、原生对象并说明其定义。"></a>9、列举宿主对象、内置对象、原生对象并说明其定义。</h3><p>宿主对象是指由宿主环境（如浏览器）提供的对象，比如 window、document 等。内置对象是指由 ECMAScript 规范定义的对象，比如 Object、Array、Function 等。原生对象是指由 ECMAScript 规范和宿主环境共同提供的对象，比如 Date、RegExp、DOM 中的 Element 等。</p>
<p>其中，宿主对象是在宿主环境中定义的，其行为和实现可能因宿主环境而异；内置对象是在 ECMAScript 规范中定义的，其行为和实现在所有 ECMAScript 实现中都是一致的；原生对象则是在 ECMAScript 规范和宿主环境共同定义的，其行为和实现可能因宿主环境而异，但在所有 ECMAScript 实现中都有一致的行为和实现。</p>
<p>需要注意的是，原生对象和内置对象的概念有时会被混淆。在某些文献中，原生对象也被称为内置对象。但在本题中，我们按照 ECMAScript 规范的定义，将原生对象和内置对象分别列举。</p>
<h3 id="10、-和-的区别"><a href="#10、-和-的区别" class="headerlink" title="10、===和 ==的区别?"></a>10、===和 ==的区别?</h3><p>===和==的区别在于，===是严格相等，不仅要求值相等，还要求类型相等；而==是相等，只要求值相等，不要求类型相等。例如，1===1和1==1都是true，但是1===’1’是false，而1==’1’是true。因此，在比较时，如果要求值和类型都相等，应该使用===；如果只要求值相等，可以使用==。</p>
<h3 id="11、null，undefined-的区别"><a href="#11、null，undefined-的区别" class="headerlink" title="11、null，undefined 的区别"></a>11、null，undefined 的区别</h3><p>null 和 undefined 都表示没有值，但是它们的含义略有不同。undefined 表示一个变量未定义或者一个属性不存在，而 null 表示一个变量已经定义但是值为空。在使用时，undefined 通常表示未定义或者缺失，而 null 表示空值或者无效值。</p>
<h3 id="12、什么情况下会返回-undefined-值"><a href="#12、什么情况下会返回-undefined-值" class="headerlink" title="12、什么情况下会返回 undefined 值?"></a>12、什么情况下会返回 undefined 值?</h3><p>在 JavaScript 中，当一个变量被声明但未被赋值时，它的值为 undefined。此外，如果一个函数没有返回值或者返回语句没有指定返回值，则该函数的返回值为 undefined。还有一种情况是当访问一个对象中不存在的属性时，会返回 undefined。</p>
<h3 id="13、如何区分数组和对象"><a href="#13、如何区分数组和对象" class="headerlink" title="13、如何区分数组和对象?"></a>13、如何区分数组和对象?</h3><p>在 JavaScript 中，可以通过 typeof 运算符来判断一个变量的类型。当 typeof 运算符作用于一个数组时，会返回字符串 “object”，而作用于一个对象时，会返回字符串 “object”。因此，我们可以通过 Array.isArray() 方法来判断一个变量是否为数组，如果是数组则返回 true，否则返回 false。</p>
<h3 id="14、多维数组如何降维"><a href="#14、多维数组如何降维" class="headerlink" title="14、多维数组如何降维?"></a>14、多维数组如何降维?</h3><p>在 JavaScript 中，可以使用数组的 flat() 方法将多维数组降维为一维数组。如果需要将多维数组完全降维为一维数组，可以使用 flat() 方法的参数 Infinity。例如，arr.flat(Infinity) 可以将多维数组 arr 降维为一维数组。</p>
<p>使用数组中的flat()方法可以将一个多维的数组降维；flat(param)方法可以传参指定递归深度；但是flat()方法会忽略空位；</p>
<p>const arr = [[1, 2], 5, “3”, [“”], 7, “”, 8, 9];</p>
<p>console.log(arr.flat(Infinity).map((x) =&gt; (x === undefined ? “” : x)));</p>
<h3 id="15、怎么获取当前日期-年-月-日-时-分-秒"><a href="#15、怎么获取当前日期-年-月-日-时-分-秒" class="headerlink" title="15、怎么获取当前日期 (年-月-日 时:分:秒) ?"></a>15、怎么获取当前日期 (年-月-日 时:分:秒) ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以使用<span class="title class_">JavaScript</span>中的<span class="title class_">Date</span>对象来获取当前日期时间，具体方法如下：</span><br><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> year = now.<span class="title function_">getFullYear</span>();</span><br><span class="line"><span class="keyword">const</span> month = now.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> date = now.<span class="title function_">getDate</span>();</span><br><span class="line"><span class="keyword">const</span> hour = now.<span class="title function_">getHours</span>();</span><br><span class="line"><span class="keyword">const</span> minute = now.<span class="title function_">getMinutes</span>();</span><br><span class="line"><span class="keyword">const</span> second = now.<span class="title function_">getSeconds</span>();</span><br><span class="line"><span class="keyword">const</span> currentTime = year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + date + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + minute + <span class="string">&#x27;:&#x27;</span> + second;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(currentTime);</span><br></pre></td></tr></table></figure>
<p>其中，getYear()方法获取的是当前年份减去1900，因此需要使用getFullYear()方法获取当前年份；getMonth()方法获取的是0-11的月份，因此需要加1；其他方法则直接获取即可。最后将获取到的年月日时分秒拼接成字符串即可。</p>
<h3 id="16、什么是类数组-伪数组-，如何将其转化为真实的数组？"><a href="#16、什么是类数组-伪数组-，如何将其转化为真实的数组？" class="headerlink" title="16、什么是类数组(伪数组)，如何将其转化为真实的数组？"></a>16、什么是类数组(伪数组)，如何将其转化为真实的数组？</h3><p>类数组是一种类似数组的对象，它具有类似数组的特性，例如可以通过索引访问元素，但它并不是真正的数组，因为它没有数组的方法和属性。将类数组转化为真实的数组可以使用Array.from()方法或者Array.prototype.slice.call()方法，也可以使用ES6的展开运算符(…)。</p>
<h4 id="17、如何遍历对象的属性"><a href="#17、如何遍历对象的属性" class="headerlink" title="17、如何遍历对象的属性?"></a>17、如何遍历对象的属性?</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123; <span class="comment">// 对象的属性名为 key，属性值为 obj[key] &#125;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，for…in 循环会遍历对象自身及其原型链上的所有可枚举属性，因此需要使用 hasOwnProperty 方法来判断属性是否为对象自身的属性。</p>
<h3 id="18、如何给一个按钮绑定两个-onclick-事件"><a href="#18、如何给一个按钮绑定两个-onclick-事件" class="headerlink" title="18、如何给一个按钮绑定两个 onclick 事件?"></a>18、如何给一个按钮绑定两个 onclick 事件?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用addEventListener()方法来为按钮绑定多个事件处理函数，而不是使用onclick属性。例如：</span></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 第一个事件处理函数 &#125;); </span></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 第二个事件处理函数 &#125;);</span></span><br></pre></td></tr></table></figure>
<p>这样，当按钮被点击时，两个事件处理函数都会被执行。</p>
<h3 id="19、变量提升是什么-与函数提升的区别"><a href="#19、变量提升是什么-与函数提升的区别" class="headerlink" title="19、变量提升是什么?与函数提升的区别?"></a>19、变量提升是什么?与函数提升的区别?</h3><p>变量提升是指在JavaScript代码执行前，变量声明会被提升到作用域的顶部，但是变量的赋值不会被提升。函数提升是指函数声明会被提升到作用域的顶部，可以在函数声明之前调用函数。二者的区别在于变量提升只会提升变量的声明，而函数提升会提升整个函数的声明。</p>
<h3 id="20、什么是作用域链-如何延长"><a href="#20、什么是作用域链-如何延长" class="headerlink" title="20、什么是作用域链?如何延长?"></a>20、什么是作用域链?如何延长?</h3><p>作用域链是指在当前执行环境中，变量和函数的查找顺序。当访问一个变量时，会先从当前作用域查找，如果没有找到，就会沿着作用域链向上查找，直到找到该变量或者到达全局作用域。作用域链的延长可以通过函数作用域和with语句来实现。函数作用域可以通过在函数内部定义变量来延长作用域链，而with语句可以将一个对象添加到作用域链的前端。</p>
<h3 id="21、如何实现数组的随机排序"><a href="#21、如何实现数组的随机排序" class="headerlink" title="21、如何实现数组的随机排序?"></a>21、如何实现数组的随机排序?</h3><p>可以使用数组的 sort 方法结合 Math.random() 实现数组的随机排序。具体实现方式为：对数组进行排序时，每次比较两个元素时，通过 Math.random() 生成一个随机数，根据随机数的大小来决定两个元素的位置交换与否。代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shuffle</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22、dom-节点的-Attribute-和-Property-有何区别"><a href="#22、dom-节点的-Attribute-和-Property-有何区别" class="headerlink" title="22、dom 节点的 Attribute 和 Property 有何区别?"></a>22、dom 节点的 Attribute 和 Property 有何区别?</h3><p>Attribute 是 HTML 元素在文档中的属性，而 Property 是 DOM 元素对象的属性。Attribute 可以看作是 HTML 标签上的属性，而 Property 是 DOM 对象上的属性。Attribute 的值可以是字符串，而 Property 的值可以是任意 JavaScript 类型。在 HTML 中设置 Attribute 的值会随着 HTML 的解析而改变，而 Property 的值可以随时改变。当 Attribute 的值改变时，对应的 Property 的值也会改变，反之亦然。但是，有些 Attribute 和 Property 的值并不相同，比如 input 元素的 value 属性和 value Attribute。</p>
<h3 id="23、dom-结构操作怎样添加、移除、移动、复制、创建和查找节点"><a href="#23、dom-结构操作怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="23、dom 结构操作怎样添加、移除、移动、复制、创建和查找节点?"></a>23、dom 结构操作怎样添加、移除、移动、复制、创建和查找节点?</h3><p>添加节点可以使用 <code>appendChild()</code>、<code>insertBefore()</code> 和 <code>innerHTML</code> 等方法；</p>
<p>移除节点可以使用 <code>removeChild()</code> 方法；</p>
<p>移动节点可以使用 <code>insertBefore()</code> 和 <code>appendChild()</code> 方法；</p>
<p>复制节点可以使用 <code>cloneNode()</code> 方法；创建节点可以使用 <code>createElement()</code> 方法；</p>
<p>查找节点可以使用 <code>getElementById()</code>、<code>getElementsByClassName()</code>、<code>getElementsByTagName()</code> 和 <code>querySelector()</code> 等方法。</p>
<p>在进行 DOM 操作时，需要注意避免频繁操作 DOM，以及避免出现内存泄漏等问题。</p>
<ol>
<li>如何添加节点？</li>
</ol>
<p>可以使用 <code>appendChild()</code> 方法将一个节点添加到父节点的子节点列表的末尾，也可以使用 <code>insertBefore()</code> 方法将一个节点插入到指定节点之前。</p>
<ol>
<li>如何移除节点？</li>
</ol>
<p>可以使用 <code>removeChild()</code> 方法从父节点中删除一个子节点。</p>
<ol>
<li>如何移动节点？</li>
</ol>
<p>可以使用 <code>appendChild()</code> 方法将一个节点从一个父节点移动到另一个父节点。</p>
<ol>
<li>如何复制节点？</li>
</ol>
<p>可以使用 <code>cloneNode()</code> 方法复制一个节点，如果传入参数 <code>true</code>，则会连同子节点一起复制。</p>
<ol>
<li>如何创建节点？</li>
</ol>
<p>可以使用 <code>createElement()</code> 方法创建一个元素节点，使用 <code>createTextNode()</code> 方法创建一个文本节点。</p>
<ol>
<li>如何查找节点？</li>
</ol>
<p>可以使用 <code>getElementById()</code> 方法根据 id 查找节点，使用 <code>getElementsByTagName()</code> 方法根据标签名查找节点，使用 <code>getElementsByClassName()</code> 方法根据类名查找节点，使用 <code>querySelector()</code> 和 <code>querySelectorAll()</code> 方法根据选择器查找节点。</p>
<h3 id="24、什么是事件冒泡，它是如何工作的-如何阻止事件冒泡"><a href="#24、什么是事件冒泡，它是如何工作的-如何阻止事件冒泡" class="headerlink" title="24、什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?"></a>24、什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?</h3><p>事件冒泡是指当一个元素触发某个事件时，该事件会从该元素开始向上冒泡，直到冒泡到文档根节点为止。在冒泡过程中，如果某个祖先元素也绑定了相同的事件，那么该事件也会被触发。</p>
<p>阻止事件冒泡可以使用事件对象的 stopPropagation() 方法。调用该方法可以阻止事件继续向上冒泡，从而避免其他元素的事件处理程序被触发。</p>
<h3 id="25、什么是事件捕获，它是如何工作的"><a href="#25、什么是事件捕获，它是如何工作的" class="headerlink" title="25、什么是事件捕获，它是如何工作的?"></a>25、什么是事件捕获，它是如何工作的?</h3><p>事件捕获是指从文档根节点开始，逐级向下传递事件，直到事件触发目标元素。与事件冒泡相反，事件捕获是从外向内传递事件。在事件捕获阶段，事件从最外层的元素开始传递，直到传递到事件的目标元素。事件捕获阶段是在事件冒泡阶段之前执行的。可以使用 addEventListener() 方法来绑定事件捕获。</p>
<h3 id="26、如何让事件先冒泡后捕获"><a href="#26、如何让事件先冒泡后捕获" class="headerlink" title="26、如何让事件先冒泡后捕获?"></a>26、如何让事件先冒泡后捕获?</h3><p>在添加事件监听器时，可以通过设置 <code>useCapture</code> 参数为 <code>true</code> 来启用事件捕获。如果设置为 <code>false</code> 或省略该参数，则默认使用事件冒泡。如果需要先进行事件冒泡再进行事件捕获，可以先设置 <code>useCapture</code> 参数为 <code>false</code>，然后在事件处理函数中手动调用 <code>event.stopPropagation()</code> 方法来阻止事件继续冒泡，最后再添加一个使用 <code>true</code> 参数的事件监听器来进行事件捕获。这样就可以实现先冒泡后捕获的效果。</p>
<h3 id="27、JavaScript-动画和-CSS3-动画有什么区别"><a href="#27、JavaScript-动画和-CSS3-动画有什么区别" class="headerlink" title="27、JavaScript 动画和 CSS3 动画有什么区别?"></a>27、JavaScript 动画和 CSS3 动画有什么区别?</h3><p>JavaScript 动画和 CSS3 动画的区别在于实现方式和性能。JavaScript 动画是通过改变元素的属性值来实现动画效果，而 CSS3 动画是通过 CSS3 的动画属性来实现动画效果。在性能方面，CSS3 动画通常比 JavaScript 动画更流畅，因为它们是由浏览器的 GPU 加速处理的。但是，JavaScript 动画更加灵活，可以实现更复杂的动画效果。</p>
<h3 id="28、dom-的事件模型"><a href="#28、dom-的事件模型" class="headerlink" title="28、dom 的事件模型 ?"></a>28、dom 的事件模型 ?</h3><p>DOM 的事件模型是一种处理 HTML、XML 或 XHTML 文档中发生的事件的方式。它包括三个阶段：捕获阶段、目标阶段和冒泡阶段。事件从最外层的元素开始捕获，然后到达目标元素，最后冒泡回最外层的元素。在每个阶段，可以注册事件监听器来处理事件。</p>
<h3 id="29、事件三要素是什么"><a href="#29、事件三要素是什么" class="headerlink" title="29、事件三要素是什么?"></a>29、事件三要素是什么?</h3><p>事件三要素是事件源、事件类型和事件处理程序。事件源是触发事件的对象，事件类型是事件的类型，例如 click、mouseover 等，事件处理程序是事件触发后执行的代码块。</p>
<h3 id="30、获取元素位置"><a href="#30、获取元素位置" class="headerlink" title="30、获取元素位置?"></a>30、获取元素位置?</h3><p>获取元素位置可以使用 DOM 元素的 <code>getBoundingClientRect()</code> 方法，该方法返回一个包含元素位置信息的对象，包括元素的左、上、右、下、宽度和高度等属性。也可以使用 <code>offsetLeft</code>、<code>offsetTop</code>、<code>offsetWidth</code> 和 <code>offsetHeight</code> 等属性获取元素相对于其定位父元素的位置和尺寸。此外，还可以使用 <code>scrollLeft</code> 和 <code>scrollTop</code> 属性获取元素的滚动位置。</p>
<h3 id="31、如何绑定事件，如何解除事件"><a href="#31、如何绑定事件，如何解除事件" class="headerlink" title="31、如何绑定事件，如何解除事件?"></a>31、如何绑定事件，如何解除事件?</h3><p>绑定事件可以使用addEventListener()方法，解除事件可以使用removeEventListener()方法。这两个方法都需要传入三个参数：事件类型、事件处理函数、是否在捕获阶段处理事件。</p>
<h3 id="32、对事件委托的理解"><a href="#32、对事件委托的理解" class="headerlink" title="32、对事件委托的理解"></a>32、对事件委托的理解</h3><p>事件委托是利用事件冒泡机制，将事件绑定在父元素上，通过判断事件源来执行相应的操作。相比直接绑定在子元素上，事件委托具有更好的性能和可维护性，尤其是在大量元素上绑定事件时。</p>
<h3 id="33、setTimeout-和-setInterval-的区别及用法是什么"><a href="#33、setTimeout-和-setInterval-的区别及用法是什么" class="headerlink" title="33、setTimeout 和 setInterval 的区别及用法是什么?"></a>33、setTimeout 和 setInterval 的区别及用法是什么?</h3><p>setTimeout 和 setInterval 都是 JavaScript 中的定时器函数，用于在指定的时间间隔后执行一次或多次函数。它们的区别在于：</p>
<ol>
<li>setTimeout 只会执行一次函数，而 setInterval 会重复执行函数。</li>
<li>setTimeout 的时间间隔是在函数执行后开始计算的，而 setInterval 的时间间隔是在函数执行前就开始计算的。</li>
<li>如果在 setTimeout 的时间间隔内再次调用 setTimeout，那么前一个定时器会被清除，而 setInterval 不会受到影响。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout 和 setInterval 的用法如下：</span></span><br><span class="line"><span class="comment">// setTimeout 用法</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval 用法</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，setTimeout 会在 1 秒后执行一次函数，而 setInterval 会每隔 1 秒执行一次函数，直到计数器 count 大于 10，然后清除定时器。</p>
<p>setTimeout 和 setInterval 都是 JavaScript 中用于延迟执行代码的函数，它们的区别在于：</p>
<ol>
<li>setTimeout 只执行一次，而 setInterval 会一直执行，直到被 clearInterval 停止。</li>
<li>setTimeout 的延迟时间是在代码执行完后开始计算的，而 setInterval 的延迟时间是在每次执行完后开始计算的。</li>
<li>setTimeout 和 setInterval 的返回值都是一个唯一的标识符，可以用于取消定时器。</li>
</ol>
<p>setTimeout 和 setInterval 的用法是：</p>
<ol>
<li>setTimeout(fn, delay)：延迟 delay 毫秒后执行一次 fn 函数。</li>
<li>setInterval(fn, delay)：每隔 delay 毫秒执行一次 fn 函数，直到被 clearInterval 停止。</li>
</ol>
<p>在实际应用中，setTimeout 和 setInterval 可以用于实现动画效果、定时刷新数据等功能。需要注意的是，过多的使用定时器可能会导致性能问题，应该谨慎使用。</p>
<h3 id="34、用-setTimeout-来实现-setInterval"><a href="#34、用-setTimeout-来实现-setInterval" class="headerlink" title="34、用 setTimeout 来实现 setInterval"></a>34、用 setTimeout 来实现 setInterval</h3><p>因为 setInterval 可能会出现一些问题，比如执行时间不准确、连续执行多次等。而使用 setTimeout 可以避免这些问题，因为它可以控制每次执行的时间间隔。具体实现方式是在 setTimeout 的回调函数中再次调用 setTimeout，以达到类似 setInterval 的效果。</p>
<p>你可以使用递归调用 setTimeout 来模拟 setInterval 的效果。在每次 setTimeout 的回调函数中，再次调用 setTimeout 来实现循环执行。需要注意的是，由于 setTimeout 的执行时间不是精确的，所以在每次回调函数中需要重新计算下一次 setTimeout 的延迟时间，以保证间隔时间的准确性。</p>
<h3 id="35-、document-write-和-innerHTML-的区别"><a href="#35-、document-write-和-innerHTML-的区别" class="headerlink" title="35 、document.write 和 innerHTML 的区别?"></a>35 、document.write 和 innerHTML 的区别?</h3><p>document.write 和 innerHTML 都可以用来向 HTML 文档中写入内容，但是它们的使用方式和效果不同。document.write 是直接向 HTML 文档中写入内容，如果在文档加载完成后使用 document.write，它会覆盖整个文档。而 innerHTML 是将内容插入到指定元素的内部，不会影响其他元素。此外，innerHTML 还可以用来获取元素的内容，而 document.write 不能。因此，一般情况下，我们更推荐使用 innerHTML 来操作 HTML 元素的内容。</p>
<p>document.write和innerHTML都可以用于向HTML文档中添加内容，但它们的实现方式不同。document.write是直接向HTML文档中写入内容，而innerHTML是将内容添加到指定元素的内部HTML中。因此，使用document.write会覆盖整个文档，而innerHTML只会影响指定元素的内容。此外，document.write只能在文档加载时使用，而innerHTML可以在任何时候使用。</p>
<h3 id="36-元素拖动如何实现，原理是怎样"><a href="#36-元素拖动如何实现，原理是怎样" class="headerlink" title="36.元素拖动如何实现，原理是怎样?"></a>36.元素拖动如何实现，原理是怎样?</h3><ol>
<li><p>监听鼠标按下事件（mousedown），记录鼠标按下时的位置和需要拖动的元素的位置。</p>
</li>
<li><p>监听鼠标移动事件（mousemove），计算鼠标移动的距离，并将需要拖动的元素的位置设置为鼠标移动的距离加上鼠标按下时元素的位置。</p>
</li>
<li><p>监听鼠标松开事件（mouseup），停止拖动。</p>
</li>
</ol>
<p>原理是通过改变元素的位置来实现拖动效果。在鼠标移动时，计算鼠标移动的距离，并将需要拖动的元素的位置设置为鼠标移动的距离加上鼠标按下时元素的位置，从而实现元素的拖动。</p>
<h3 id="37、什么是重绘-repaint-什么是回流-reflow-如何最小化重绘和回流"><a href="#37、什么是重绘-repaint-什么是回流-reflow-如何最小化重绘和回流" class="headerlink" title="37、什么是重绘(repaint)? 什么是回流(reflow)? 如何最小化重绘和回流?"></a>37、什么是重绘(repaint)? 什么是回流(reflow)? 如何最小化重绘和回流?</h3><p>重绘是指当元素样式改变，但是不影响其布局时，浏览器会重新绘制该元素，这个过程叫做重绘。而回流是指当元素的尺寸、位置或者内容发生改变时，浏览器会重新计算元素的几何属性和布局，然后再将计算结果绘制出来，这个过程叫做回流。</p>
<p>为了最小化重绘和回流，我们可以采取以下措施：</p>
<ol>
<li><p>避免频繁操作样式，可以将多次操作合并为一次，或者使用 CSS class 来一次性修改样式。</p>
</li>
<li><p>将需要多次操作的元素，先脱离文档流，操作完成后再放回文档流，这样可以减少回流次数。</p>
</li>
<li><p>使用文档片段(document fragment)来操作 DOM，可以减少回流次数。</p>
</li>
<li><p>将复杂的动画效果应用到 position 属性为 fixed 或 absolute 的元素上，这样可以减少其他元素的回流次数。</p>
</li>
<li><p>尽量使用 CSS3 动画，避免使用 JavaScript 操作 DOM。</p>
</li>
</ol>
<h3 id="38、延迟加载的方式有哪些"><a href="#38、延迟加载的方式有哪些" class="headerlink" title="38、延迟加载的方式有哪些?"></a>38、延迟加载的方式有哪些?</h3><ol>
<li><p>懒加载：将页面分块，当用户滚动到某个区域时再加载该区域的内容，常用于图片和视频等资源的加载。</p>
</li>
<li><p>预加载：提前加载将要使用的资源，常用于图片和音视频等资源的加载。</p>
</li>
<li><p>按需加载：根据用户的操作或需求，动态加载所需的资源，常用于页面交互和异步加载数据等场景。</p>
</li>
<li><p>骨架屏：在页面加载过程中，先展示页面结构和基本布局，再逐步加载内容和样式，提高用户体验。</p>
</li>
</ol>
<h3 id="39、垃圾回收机制有哪些-具体怎么如何执行"><a href="#39、垃圾回收机制有哪些-具体怎么如何执行" class="headerlink" title="39、垃圾回收机制有哪些? 具体怎么如何执行?"></a>39、垃圾回收机制有哪些? 具体怎么如何执行?</h3><p>垃圾回收机制主要有标记清除、引用计数和增量标记三种。其中标记清除和引用计数是最常见的两种。标记清除是通过标记不再使用的对象，然后清除它们的内存空间。引用计数是通过记录每个对象被引用的次数，当引用次数为0时，就清除该对象的内存空间。增量标记是在标记清除的基础上，将标记和清除的过程分成多个小步骤，以减少对程序的影响。垃圾回收机制的具体执行方式和实现细节因浏览器而异，但一般都是在程序运行时自动执行的。</p>
<p>垃圾回收机制是指浏览器自动回收不再使用的内存空间的一种机制。常见的垃圾回收机制有标记清除、引用计数和增量垃圾回收等。其中，标记清除是最常用的垃圾回收机制，它通过标记不再使用的对象，然后回收这些对象所占用的内存空间。引用计数则是通过计算对象被引用的次数来判断是否需要回收。增量垃圾回收则是将垃圾回收的过程分成多个小步骤，以减少垃圾回收对程序的影响。</p>
<p>具体执行过程是，当浏览器需要回收内存时，会先暂停程序的执行，然后遍历内存中的对象，标记出所有不再使用的对象。接着，浏览器会将这些对象所占用的内存空间释放掉，以便其他对象可以使用。最后，浏览器会恢复程序的执行。</p>
<p>需要注意的是，垃圾回收机制是自动执行的，程序员无法手动触发。但是，程序员可以通过编写高效的代码和避免内存泄漏等方式来减少垃圾回收的次数，从而提高程序的性能。</p>
<h3 id="40、什么是内存泄漏"><a href="#40、什么是内存泄漏" class="headerlink" title="40、什么是内存泄漏 ?"></a>40、什么是内存泄漏 ?</h3><p>内存泄漏是指在程序运行过程中，由于某些原因导致已经不再使用的内存空间没有被及时释放，从而造成系统内存的浪费和程序运行速度的下降。</p>
<h3 id="41、数组遍历的方法有哪些，分别有什么特点，性能如何"><a href="#41、数组遍历的方法有哪些，分别有什么特点，性能如何" class="headerlink" title="41、数组遍历的方法有哪些，分别有什么特点，性能如何 ?"></a>41、数组遍历的方法有哪些，分别有什么特点，性能如何 ?</h3><ol>
<li>for循环：传统的遍历方式，性能较好，但代码量较大。</li>
<li>forEach：ES5新增的方法，语法简洁，但无法中途跳出循环。</li>
<li>map：ES5新增的方法，可以遍历数组并返回一个新的数组，常用于数据转换。</li>
<li>filter：ES5新增的方法，可以遍历数组并返回符合条件的元素组成的新数组。</li>
<li>reduce：ES5新增的方法，可以遍历数组并对数组元素进行累加、计算等操作。</li>
</ol>
<p>这些方法的性能差异不大，但在特定场景下可能会有所不同。一般来说，for循环的性能最好，而forEach的性能最差。但在实际开发中，应根据具体情况选择最适合的遍历方法。</p>
<h3 id="42、ES5-和-ES6-的区别，ES6-新增了什么"><a href="#42、ES5-和-ES6-的区别，ES6-新增了什么" class="headerlink" title="42、ES5 和 ES6 的区别，ES6 新增了什么?"></a>42、ES5 和 ES6 的区别，ES6 新增了什么?</h3><p>ES5和ES6是JavaScript的两个版本，ES6是ES5的升级版。ES6新增了许多新特性，包括箭头函数、模板字符串、解构赋值、let和const关键字、类和模块等。这些新特性使得JavaScript更加现代化、易读易写、可维护性更高。同时，ES6也提供了更好的支持异步编程的解决方案，如Promise和async/await。总的来说，ES6的新增特性使得JavaScript更加强大和灵活，让开发者能够更加高效地编写代码。</p>
<h3 id="43、ES6-的继承和-ES5-的继承有什么区别"><a href="#43、ES6-的继承和-ES5-的继承有什么区别" class="headerlink" title="43、ES6 的继承和 ES5 的继承有什么区别?"></a>43、ES6 的继承和 ES5 的继承有什么区别?</h3><p>ES6 的继承使用了 class 和 extends 关键字，更加简洁易懂，支持 super 关键字调用父类构造函数和方法，同时支持子类重写父类方法。而 ES5 的继承则是通过原型链实现，需要手动设置子类的原型对象指向父类的实例，语法较为繁琐，不够直观。</p>
<h3 id="44、var、let、const-之间的区别-暂时性死区如何理解"><a href="#44、var、let、const-之间的区别-暂时性死区如何理解" class="headerlink" title="44、var、let、const 之间的区别? 暂时性死区如何理解?"></a>44、var、let、const 之间的区别? 暂时性死区如何理解?</h3><p>暂时性死区是指在 let 或 const 声明变量之前，该变量是不可访问的。这是因为在块级作用域内，let 和 const 声明的变量在声明之前是不存在的，因此访问这些变量会导致 ReferenceError 错误。</p>
<h3 id="45、Class、extends-是什么，有什么作用"><a href="#45、Class、extends-是什么，有什么作用" class="headerlink" title="45、Class、extends 是什么，有什么作用?"></a>45、Class、extends 是什么，有什么作用?</h3><p>Class 是 ES6 中引入的一种新的语法，用于定义一个类。它可以看作是一个模板，用于创建对象的实例。extends 是 Class 中的一个关键字，用于实现继承。它可以让一个类继承另一个类的属性和方法，从而实现代码的复用和扩展。通过 Class 和 extends，我们可以更加方便地组织和管理代码，提高代码的可读性和可维护性。</p>
<h3 id="46、什么是-JS-闭包？"><a href="#46、什么是-JS-闭包？" class="headerlink" title="46、什么是 JS 闭包？"></a>46、什么是 JS 闭包？</h3><p>JS闭包是指一个函数能够访问并操作其外部函数作用域中的变量，即使外部函数已经执行完毕并返回。闭包可以用来创建私有变量和函数，以及实现高阶函数等功能。</p>
<h3 id="47-、说一下类的创建和继承，列举一下你所知道的继承方式"><a href="#47-、说一下类的创建和继承，列举一下你所知道的继承方式" class="headerlink" title="47 、说一下类的创建和继承，列举一下你所知道的继承方式"></a>47 、说一下类的创建和继承，列举一下你所知道的继承方式</h3><p>类的创建和继承是面向对象编程的基础，类是一种抽象的概念，用于描述一类具有相同属性和方法的对象。在 JavaScript 中，类的创建可以使用 class 关键字，继承可以使用 extends 关键字。常见的继承方式有原型链继承、构造函数继承、组合继承、寄生组合继承等。</p>
<h3 id="48、如何解决异步回调地狱-？"><a href="#48、如何解决异步回调地狱-？" class="headerlink" title="48、如何解决异步回调地狱 ？"></a>48、如何解决异步回调地狱 ？</h3><ol>
<li><p>使用 Promise：Promise 可以将异步操作转换为链式调用，避免回调嵌套。</p>
</li>
<li><p>使用 async/await：async/await 是基于 Promise 的语法糖，可以让异步代码看起来像同步代码，更易于阅读和维护。</p>
</li>
<li><p>使用事件发布/订阅模式：通过事件发布/订阅模式，可以将异步操作拆分为多个独立的事件，避免回调嵌套。</p>
</li>
<li><p>使用生成器函数：生成器函数可以暂停和恢复代码执行，可以将异步操作拆分为多个独立的步骤，避免回调嵌套。</p>
</li>
</ol>
<h3 id="49、说一下图片的懒加载和预加载"><a href="#49、说一下图片的懒加载和预加载" class="headerlink" title="49、说一下图片的懒加载和预加载"></a>49、说一下图片的懒加载和预加载</h3><p>图片的懒加载是指在页面加载时，只加载可视区域内的图片，当用户滚动页面时再加载其他图片，以提高页面加载速度和用户体验。</p>
<p>图片的预加载是指在页面加载时，提前加载所有图片，以确保用户在浏览时能够立即看到图片，避免等待加载的时间。预加载可以通过 JavaScript 的 Image 对象或者 CSS 的 background-image 属性来实现。</p>
<h3 id="50、mouseover-和-mouseenter-的区别"><a href="#50、mouseover-和-mouseenter-的区别" class="headerlink" title="50、mouseover 和 mouseenter 的区别"></a>50、mouseover 和 mouseenter 的区别</h3><p>mouseover 和 mouseenter 都是鼠标事件，但它们的区别在于，mouseover 会在鼠标进入元素和元素内部的子元素时触发，而 mouseenter 只会在鼠标进入元素时触发，不会在进入子元素时触发。此外，mouseenter 和 mouseleave 是成对出现的，而 mouseover 和 mouseout 也是成对出现的。</p>
<h3 id="51-、new-操作符做了哪些事情？"><a href="#51-、new-操作符做了哪些事情？" class="headerlink" title="51 、new 操作符做了哪些事情？"></a>51 、new 操作符做了哪些事情？</h3><p>new 操作符主要做了以下三件事情：</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型指向构造函数的原型对象。</li>
<li>将构造函数的 this 指向这个空对象，并执行构造函数内部的代码，初始化对象的属性和方法。最后返回这个对象实例。</li>
</ol>
<h3 id="52、-改变函数内部-this-指针的指向函数-bind，apply，call-的区别-，内在分别是如何实现的"><a href="#52、-改变函数内部-this-指针的指向函数-bind，apply，call-的区别-，内在分别是如何实现的" class="headerlink" title="52、 改变函数内部 this 指针的指向函数 (bind，apply，call 的区别)，内在分别是如何实现的?"></a>52、 改变函数内部 this 指针的指向函数 (bind，apply，call 的区别)，内在分别是如何实现的?</h3><ol>
<li>改变函数内部 this 指针的指向函数有哪些？它们之间有什么区别？</li>
</ol>
<p>答：改变函数内部 this 指针的指向函数有 bind、apply 和 call。它们的区别在于传参方式不同：bind 是返回一个新函数，需要手动调用；apply 和 call 则是直接调用函数并传入参数，区别在于传参方式不同，apply 接收一个数组作为参数，而 call 则是一个一个传参。</p>
<ol>
<li>这些函数内部是如何实现改变 this 指针的？</li>
</ol>
<p>答：这些函数内部都是通过改变函数的执行上下文来实现改变 this 指针的。apply 和 call 是直接改变函数的执行上下文，而 bind 是返回一个新函数，新函数的执行上下文被绑定为 bind 的第一个参数。</p>
<h3 id="53、JS-的各种位置，比如-clientHeight-scrolHeight-offsetHeight-以及-scrolTop-offsetTop-clientTop-的区别"><a href="#53、JS-的各种位置，比如-clientHeight-scrolHeight-offsetHeight-以及-scrolTop-offsetTop-clientTop-的区别" class="headerlink" title="53、JS 的各种位置，比如 clientHeight, scrolHeight, offsetHeight ,以及 scrolTop, offsetTop, clientTop 的区别?"></a>53、JS 的各种位置，比如 clientHeight, scrolHeight, offsetHeight ,以及 scrolTop, offsetTop, clientTop 的区别?</h3><p>clientHeight、clientTop、scrollTop是针对可视区域的属性，而scrollHeight、offsetHeight、offsetTop是针对元素本身的属性。</p>
<ul>
<li>clientHeight：元素可视区域的高度，不包含border和滚动条。</li>
<li>scrollHeight：元素内容的高度，包含溢出部分的高度。</li>
<li>offsetHeight：元素自身的高度，包含border、padding和滚动条（如果存在）。</li>
<li>scrollTop：元素滚动条向下滚动的距离。</li>
<li>offsetTop：元素相对于offsetParent元素的顶部距离。</li>
<li>clientTop：元素上边框的宽度。</li>
</ul>
<p>其中，offsetParent是指离当前元素最近的已定位（position不为static）的祖先元素，如果没有则为body元素。</p>
<h3 id="54、异步加载JS的方法"><a href="#54、异步加载JS的方法" class="headerlink" title="54、异步加载JS的方法"></a>54、异步加载JS的方法</h3><p>异步加载JS的方法有两种：使用动态创建script标签和使用XMLHttpRequest对象。使用动态创建script标签的方法是在页面中创建一个script标签，然后设置其src属性为要加载的JS文件的URL，最后将该标签添加到页面中。使用XMLHttpRequest对象的方法是创建一个XMLHttpRequest对象，然后使用该对象的open方法打开要加载的JS文件的URL，最后使用该对象的send方法发送请求并接收响应。这两种方法都可以异步加载JS文件，提高页面加载速度和性能。</p>
<h3 id="55、Ajax-解决浏览器缓存问题"><a href="#55、Ajax-解决浏览器缓存问题" class="headerlink" title="55、Ajax 解决浏览器缓存问题"></a>55、Ajax 解决浏览器缓存问题</h3><p>Ajax 解决浏览器缓存问题的方法有两种：</p>
<ol>
<li><p>在 Ajax 请求中添加随机数或时间戳参数，使每次请求的 URL 都不同，从而避免浏览器缓存。</p>
</li>
<li><p>在服务器端设置响应头，禁止浏览器缓存 Ajax 请求的响应结果。可以通过设置 Cache-Control、Expires、Pragma 等响应头来实现。</p>
</li>
</ol>
<h3 id="56、节流和防抖"><a href="#56、节流和防抖" class="headerlink" title="56、节流和防抖"></a>56、节流和防抖</h3><p>节流和防抖是两种常用的优化前端性能的方法。节流是指在一定时间内只执行一次函数，防抖是指在一定时间内只执行最后一次函数。它们的作用是减少函数的执行次数，提高页面性能和用户体验。实现节流可以使用定时器和时间戳两种方式，实现防抖可以使用定时器方式。</p>
<h3 id="57、eval-是做什么的"><a href="#57、eval-是做什么的" class="headerlink" title="57、eval 是做什么的"></a>57、eval 是做什么的</h3><p>eval 是一个 JavaScript 函数，它可以将字符串作为代码来执行。它可以将字符串解析为 JavaScript 代码，并在当前作用域中执行。但是，由于它的不安全性和潜在的性能问题，eval 应该谨慎使用。</p>
<h3 id="58-、对象深拷贝的简单实现"><a href="#58-、对象深拷贝的简单实现" class="headerlink" title="58 、对象深拷贝的简单实现"></a>58 、对象深拷贝的简单实现</h3><p>当需要复制一个对象时，可以使用对象深拷贝来创建一个新的对象，该对象与原始对象具有相同的属性和值，但是它们是不同的对象，修改一个对象不会影响另一个对象。以下是一种简单的对象深拷贝实现方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> clone = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      clone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法使用递归来遍历对象的每个属性，并创建一个新的对象来存储它们的副本。如果属性是一个对象，则递归调用 <code>deepClone</code> 方法来创建该对象的副本。如果属性是一个基本类型，则直接将其复制到新对象中。最后，返回新对象。</p>
<h3 id="59、实现-JS-中所有对象的深度克隆-包装对象，Date-对象，正则对象"><a href="#59、实现-JS-中所有对象的深度克隆-包装对象，Date-对象，正则对象" class="headerlink" title="59、实现 JS 中所有对象的深度克隆 (包装对象，Date 对象，正则对象)"></a>59、实现 JS 中所有对象的深度克隆 (包装对象，Date 对象，正则对象)</h3><p>当需要对一个对象进行深度克隆时，可以使用递归的方式遍历对象的所有属性，并创建一个新的对象来保存原对象的属性值。对于包装对象、Date 对象和正则对象，可以使用相应的构造函数来创建新的对象。以下是一个简单的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(clone).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    clone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">    clone.<span class="property">length</span> = obj.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(clone);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj.<span class="title function_">getTime</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数首先检查传入的参数是否为 null 或非对象类型，如果是则直接返回该参数。否则，使用 Object.assign() 方法创建一个新的对象，并遍历原对象的所有属性，递归地调用 deepClone() 函数来克隆每个属性的值。对于数组、Date 对象和正则对象，分别使用 Array.from()、new Date() 和 new RegExp() 来创建新的对象。最后返回克隆后的对象。</p>
<h3 id="60、实现一个-once-函数，传入函数参数只执行一次"><a href="#60、实现一个-once-函数，传入函数参数只执行一次" class="headerlink" title="60、实现一个 once 函数，传入函数参数只执行一次"></a>60、实现一个 once 函数，传入函数参数只执行一次</h3><p>可以通过闭包来实现一个 once 函数，具体实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">once</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> executed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!executed) &#123;</span><br><span class="line">      executed = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受一个函数参数 <code>fn</code>，并返回一个新的函数。新函数在第一次被调用时会执行 <code>fn</code>，并将 <code>executed</code> 标记为 <code>true</code>，以后再次调用时则不会再执行 <code>fn</code>。</p>
<h3 id="61、将原生的-ajax-封装成-promise"><a href="#61、将原生的-ajax-封装成-promise" class="headerlink" title="61、将原生的 ajax 封装成 promise"></a>61、将原生的 ajax 封装成 promise</h3><p>可以通过创建一个 Promise 对象，将原生的 ajax 封装成 promise。具体实现方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 Promise 的 then 和 catch 方法来处理 ajax 请求的成功和失败了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;https://example.com/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功：&#x27;</span> + response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败：&#x27;</span> + error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="62、JS-监听对象属性的改变"><a href="#62、JS-监听对象属性的改变" class="headerlink" title="62、JS 监听对象属性的改变"></a>62、JS 监听对象属性的改变</h3><p>可以使用 Object.defineProperty() 方法来监听对象属性的改变。该方法接受三个参数：要监听的对象、要监听的属性名和一个描述符对象。描述符对象中需要设置 get 和 set 方法，分别用于获取属性值和设置属性值。在 set 方法中可以添加属性改变时的回调函数，从而实现监听属性改变的功能。</p>
<h3 id="63、如何实现一个私有变量，用-get-可以访问，不能直接访问"><a href="#63、如何实现一个私有变量，用-get-可以访问，不能直接访问" class="headerlink" title="63、如何实现一个私有变量，用 get 可以访问，不能直接访问"></a>63、如何实现一个私有变量，用 get 可以访问，不能直接访问</h3><p>在 JavaScript 中，可以使用闭包来实现私有变量。具体实现方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> privateVar = <span class="string">&#x27;私有变量&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getPrivateVar</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> privateVar;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">privateVar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getPrivateVar</span>()); <span class="comment">// 私有变量</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，私有变量 <code>privateVar</code> 被定义在构造函数 <code>MyClass</code> 内部，外部无法直接访问。通过在构造函数内部定义一个返回私有变量的方法 <code>getPrivateVar</code>，可以通过调用该方法来访问私有变量。由于该方法是在构造函数内部定义的，因此可以访问到私有变量 <code>privateVar</code>。</p>
<h3 id="64、怎么控制一次加载一张图片，加载完后再加载下一张"><a href="#64、怎么控制一次加载一张图片，加载完后再加载下一张" class="headerlink" title="64、怎么控制一次加载一张图片，加载完后再加载下一张"></a>64、怎么控制一次加载一张图片，加载完后再加载下一张</h3><p>可以使用递归函数和 Image 对象来实现一次只加载一张图片，等待加载完毕后再加载下一张图片的效果。具体实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImage</span>(<span class="params">urls, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (urls.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">loadImage</span>(urls.<span class="title function_">slice</span>(<span class="number">1</span>), callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  img.<span class="property">src</span> = urls[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">loadImage</span>([<span class="string">&#x27;url1&#x27;</span>, <span class="string">&#x27;url2&#x27;</span>, <span class="string">&#x27;url3&#x27;</span>], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有图片加载完毕&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码中，loadImage 函数接受两个参数，第一个参数是一个图片 URL 数组，第二个参数是所有图片加载完毕后的回调函数。在 loadImage 函数内部，首先创建一个 Image 对象，然后将第一个 URL 赋值给它的 src 属性，这样就开始加载第一张图片了。当第一张图片加载完毕后，会触发 img 对象的 onload 事件，这时候判断 urls 数组中是否还有未加载的图片，如果有，则递归调用 loadImage 函数，传入剩余的图片 URL 数组和回调函数；如果没有，则说明所有图片都已经加载完毕，此时调用回调函数即可。</p>
<h3 id="65、如何在-JavaScript-中实现类似于-sleep-的效果，即暂停一段时间后再执行后续代码？可以给出-ES5-或-ES6-的实现方式。"><a href="#65、如何在-JavaScript-中实现类似于-sleep-的效果，即暂停一段时间后再执行后续代码？可以给出-ES5-或-ES6-的实现方式。" class="headerlink" title="65、如何在 JavaScript 中实现类似于 sleep 的效果，即暂停一段时间后再执行后续代码？可以给出 ES5 或 ES6 的实现方式。"></a>65、如何在 JavaScript 中实现类似于 sleep 的效果，即暂停一段时间后再执行后续代码？可以给出 ES5 或 ES6 的实现方式。</h3><p>可以使用 ES6 的 Promise 和 async/await 来实现 sleep 的效果，具体实现方式如下：</p>
<p>ES6 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 async/await：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES5：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - start &lt; ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，ES5 的实现方式会阻塞主线程，不建议在实际项目中使用。建议使用 Promise 或 async/await 的方式来实现。</p>
<h3 id="66、Function-proto-getPrototypeOf-是什么"><a href="#66、Function-proto-getPrototypeOf-是什么" class="headerlink" title="66、Function.proto(getPrototypeOf)是什么?"></a>66、Function.<em>proto</em>(getPrototypeOf)是什么?</h3><p>Function.prototype 是一个函数对象的原型，它是所有函数对象的祖先，包括自定义函数和内置函数。它定义了所有函数对象都可以访问的属性和方法，比如 call、apply、bind 等。</p>
<p>而 Object.getPrototypeOf 是一个用于获取对象原型的方法，它返回指定对象的原型。它可以用于获取任何对象的原型，包括函数对象的原型。</p>
<p>简单来说，Function.prototype 是函数对象的原型，而 Object.getPrototypeOf 则是获取任何对象的原型的方法。</p>
<h3 id="67、箭头函数中-this-指向"><a href="#67、箭头函数中-this-指向" class="headerlink" title="67、箭头函数中 this 指向"></a>67、箭头函数中 this 指向</h3><p>箭头函数中的 this 指向定义时所在的作用域，而不是调用时的作用域。这意味着箭头函数中的 this 不会被动态绑定，而是被静态绑定。通常情况下，箭头函数中的 this 指向的是其外层函数的 this，或者是全局对象（如果箭头函数没有外层函数）。因此，在箭头函数中使用 this 时需要注意上下文。</p>
<h3 id="68、-数组常用方法有哪些？"><a href="#68、-数组常用方法有哪些？" class="headerlink" title="68、 数组常用方法有哪些？"></a>68、 数组常用方法有哪些？</h3><p>数组常用方法包括 push、pop、shift、unshift、splice、slice、concat、join、reverse、sort、map、filter、reduce 等。</p>
<h3 id="69、-数组去重有哪些方法"><a href="#69、-数组去重有哪些方法" class="headerlink" title="69、 数组去重有哪些方法?"></a>69、 数组去重有哪些方法?</h3><ol>
<li><p>使用 Set 数据结构：将数组转换为 Set，再将 Set 转换为数组即可去重。</p>
</li>
<li><p>使用 filter 方法：遍历数组，将每个元素与其后面的元素进行比较，如果不重复则保留，否则过滤掉。</p>
</li>
<li><p>使用 reduce 方法：遍历数组，将每个元素与已有的元素进行比较，如果不重复则添加到已有元素中，最后返回已有元素。</p>
</li>
<li><p>使用 indexOf 方法：遍历数组，将每个元素与其前面的元素进行比较，如果不重复则保留，否则过滤掉。</p>
</li>
<li><p>使用 includes 方法：遍历数组，将每个元素与其前面的元素进行比较，如果不重复则保留，否则过滤掉。</p>
</li>
<li><p>使用 Map 数据结构：遍历数组，将每个元素作为 Map 的键，值可以随意设置，如果 Map 中已经存在该键，则说明重复，过滤掉即可。</p>
</li>
</ol>
<h3 id="70、如何去除字符串首尾空格"><a href="#70、如何去除字符串首尾空格" class="headerlink" title="70、如何去除字符串首尾空格"></a>70、如何去除字符串首尾空格</h3><p>可以使用JavaScript中的trim()方法来去除字符串首尾空格。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot; hello world &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> trimmedStr = str.<span class="title function_">trim</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStr); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>此外，还可以使用正则表达式来去除字符串中的所有空格，包括首尾空格。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot; hello world &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> trimmedStr = str.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStr); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中，正则表达式<code>/^\s+|\s+$/g</code>表示匹配字符串开头的一个或多个空格，或者字符串结尾的一个或多个空格，并将其替换为空字符串。</p>
<h3 id="71、说说你所知道的-JS-语言特性"><a href="#71、说说你所知道的-JS-语言特性" class="headerlink" title="71、说说你所知道的 JS 语言特性?"></a>71、说说你所知道的 JS 语言特性?</h3><p>JS 语言特性包括但不限于以下几点：</p>
<ol>
<li><p>动态类型：JS 是一种动态类型语言，变量的类型可以在运行时改变。</p>
</li>
<li><p>闭包：JS 支持闭包，可以在函数内部定义函数，并访问外部函数的变量。</p>
</li>
<li><p>原型继承：JS 的继承是通过原型链实现的，每个对象都有一个原型对象，可以从中继承属性和方法。</p>
</li>
<li><p>函数是一等公民：JS 中的函数可以像变量一样被传递、赋值和返回。</p>
</li>
<li><p>弱类型转换：JS 中的弱类型转换会自动将变量的类型转换为需要的类型。</p>
</li>
<li><p>事件驱动编程：JS 支持事件驱动编程，可以通过事件监听和触发来实现异步编程。</p>
</li>
<li><p>面向对象编程：JS 支持面向对象编程，可以通过构造函数和原型来创建对象和继承。</p>
</li>
<li><p>作用域链：JS 中的作用域是通过作用域链实现的，可以访问外部函数的变量。</p>
</li>
<li><p>高阶函数：JS 支持高阶函数，可以将函数作为参数或返回值传递。</p>
</li>
<li><p>单线程：JS 是一种单线程语言，只能同时执行一个任务，但可以通过异步编程来实现并发。</p>
</li>
</ol>
<h3 id="72、如何判断一个变量是否为数组？"><a href="#72、如何判断一个变量是否为数组？" class="headerlink" title="72、如何判断一个变量是否为数组？"></a>72、如何判断一个变量是否为数组？</h3><p>可以使用 <code>Array.isArray()</code> 方法来判断一个变量是否为数组。该方法会返回一个布尔值，如果变量是数组则返回 <code>true</code>，否则返回 <code>false</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> notArr = <span class="string">&#x27;not an array&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(notArr)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="73、JS-的全排列"><a href="#73、JS-的全排列" class="headerlink" title="73、JS 的全排列"></a>73、JS 的全排列</h3><p>可以使用递归的方式实现数组的全排列，具体步骤如下：</p>
<ol>
<li><p>首先判断数组的长度，如果长度为 1，则直接返回该数组。</p>
</li>
<li><p>如果数组长度大于 1，则遍历数组，将每个元素与第一个元素交换位置，然后对剩余元素进行全排列。</p>
</li>
<li><p>递归调用上一步，直到数组长度为 1。</p>
</li>
<li><p>将每次递归得到的结果合并成一个新的数组，即为原数组的全排列。</p>
</li>
</ol>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">permute</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [arr];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> first = arr[i];</span><br><span class="line">      <span class="keyword">let</span> rest = arr.<span class="title function_">slice</span>(<span class="number">0</span>, i).<span class="title function_">concat</span>(arr.<span class="title function_">slice</span>(i + <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">let</span> innerPermutations = <span class="title function_">permute</span>(rest);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; innerPermutations.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>([first].<span class="title function_">concat</span>(innerPermutations[j]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>(arr)); <span class="comment">// [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br></pre></td></tr></table></figure>
<h3 id="74、谈谈你所理解的跨域，为什么会有这个问题-如何解决"><a href="#74、谈谈你所理解的跨域，为什么会有这个问题-如何解决" class="headerlink" title="74、谈谈你所理解的跨域，为什么会有这个问题?如何解决?"></a>74、谈谈你所理解的跨域，为什么会有这个问题?如何解决?</h3><p>跨域是指在浏览器中，当前网页所在的域名与目标网页的域名不一致，就会发生跨域问题。这是由于浏览器的同源策略所导致的。同源策略是浏览器的一种安全策略，它限制了一个域下的文档或脚本如何与另一个域进行交互。</p>
<p>跨域问题可以通过以下几种方式解决：</p>
<ol>
<li><p>JSONP：利用 script 标签的跨域特性，通过动态创建 script 标签，将需要获取的数据作为参数传递给服务器，服务器返回一段调用指定函数的 JavaScript 代码，浏览器执行该代码，从而实现跨域请求。</p>
</li>
<li><p>CORS：CORS 是一种跨域资源共享的机制，它通过在服务器端设置响应头来允许跨域请求。服务器端设置 Access-Control-Allow-Origin 头部，指定允许跨域的域名，从而实现跨域请求。</p>
</li>
<li><p>代理：通过在同一域名下设置代理服务器，将跨域请求转发到目标服务器，从而实现跨域请求。</p>
</li>
<li><p>postMessage：通过在不同窗口之间传递消息，从而实现跨域通信。在当前窗口中使用 postMessage 方法向目标窗口发送消息，目标窗口通过监听 message 事件来接收消息。</p>
</li>
</ol>
<h3 id="75、null-undefined-输出什么-null-undefined-呢"><a href="#75、null-undefined-输出什么-null-undefined-呢" class="headerlink" title="75、null == undefined 输出什么? null === undefined 呢?"></a>75、null == undefined 输出什么? null === undefined 呢?</h3><p>null == undefined 输出 true，因为它们在相等比较时被认为是相等的。但是，null === undefined 输出 false，因为它们在严格比较时被认为是不同的类型。</p>
<h3 id="76、什么是按需加载"><a href="#76、什么是按需加载" class="headerlink" title="76、什么是按需加载"></a>76、什么是按需加载</h3><p>按需加载是一种优化网站性能的技术，它可以根据用户的需求，动态地加载所需的资源，而不是一次性加载所有资源。这样可以减少页面的加载时间和带宽的占用，提高用户的体验。常见的按需加载方式包括懒加载、分块加载、异步加载等。</p>
<h3 id="77、简单介绍一下-symbol"><a href="#77、简单介绍一下-symbol" class="headerlink" title="77、简单介绍一下 symbol"></a>77、简单介绍一下 symbol</h3><p>Symbol 是 ES6 中新增的一种基本数据类型，它是一种原始数据类型，表示独一无二的值。Symbol 值通过 Symbol 函数生成，可以作为对象属性的标识符使用，避免了属性名冲突的问题。Symbol 值不能与其他类型的值进行运算，也不能被强制转换为其他类型的值。Symbol 值可以用于定义对象的私有属性或方法，以及实现迭代器等功能。</p>
<h3 id="78、介绍一下-promise，及其底层如何实现"><a href="#78、介绍一下-promise，及其底层如何实现" class="headerlink" title="78、介绍一下 promise，及其底层如何实现"></a>78、介绍一下 promise，及其底层如何实现</h3><p>Promise 是一种用于处理异步操作的对象，它可以让我们更方便地处理异步操作的结果。Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。当 Promise 的状态从 pending 转换为 fulfilled 或 rejected 时，就称为 Promise 被“解决”（resolved）。</p>
<p>Promise 的基本用法是通过 new Promise() 创建一个 Promise 对象，然后使用 then() 方法来处理 Promise 的结果。then() 方法接收两个参数，第一个参数是 Promise 成功时的回调函数，第二个参数是 Promise 失败时的回调函数。</p>
<p>Promise 还有一些常见的方法，比如：</p>
<ul>
<li>Promise.all()：接收一个 Promise 数组，当所有 Promise 都成功时返回一个包含所有 Promise 结果的数组，否则返回第一个失败的 Promise 的错误信息。</li>
<li>Promise.race()：接收一个 Promise 数组，当其中任意一个 Promise 成功或失败时，返回该 Promise 的结果。</li>
<li>Promise.resolve()：将一个值或一个 Promise 对象转换为 Promise 对象。</li>
<li>Promise.reject()：将一个错误信息转换为 Promise 对象。</li>
</ul>
<p>Promise 的底层实现原理是通过回调函数和事件循环来实现的。当 Promise 被创建时，它的状态为 pending，当异步操作完成后，Promise 的状态会被改变为 fulfilled 或 rejected。then() 方法会将回调函数存储起来，当 Promise 被解决时，会依次执行这些回调函数。then() 方法的链式调用是通过返回一个新的 Promise 对象来实现的，这个新的 Promise 对象会在上一个 Promise 对象被解决后被解决。错误处理机制是通过 catch() 方法来实现的，当 Promise 被拒绝时，会依次执行 catch() 方法中的回调函数。</p>
<h3 id="79、JS-原型链，原型链的顶端是什么-0bject-的原型是什么-0bject-的原型的原型是什么"><a href="#79、JS-原型链，原型链的顶端是什么-0bject-的原型是什么-0bject-的原型的原型是什么" class="headerlink" title="79、JS 原型链，原型链的顶端是什么? 0bject 的原型是什么? 0bject 的原型的原型是什么?"></a>79、JS 原型链，原型链的顶端是什么? 0bject 的原型是什么? 0bject 的原型的原型是什么?</h3><p>JS 原型链是一种对象之间的关系模型，每个对象都有一个指向其原型的内部链接，形成了一个链式结构。当我们访问一个对象的属性时，如果该对象本身没有该属性，JS 引擎会沿着原型链向上查找，直到找到该属性或者到达原型链的顶端。</p>
<p>原型链的顶端是 Object.prototype，它是所有对象的原型，包括函数对象和普通对象。Object.prototype 的原型为 null，表示它没有原型。</p>
<p>Object 的原型是 Object.prototype，它包含了一些常用的方法和属性，如 toString、valueOf、hasOwnProperty 等。Object.prototype 的原型为 null，表示它没有原型。</p>
<h3 id="80、promise-Generator-Async-的使用"><a href="#80、promise-Generator-Async-的使用" class="headerlink" title="80、promise+Generator+Async 的使用"></a>80、promise+Generator+Async 的使用</h3><p>Promise、Generator 和 Async 都是 JavaScript 中用于处理异步编程的工具。</p>
<p>Promise 是一种用于处理异步操作的对象，它可以将异步操作转换为同步操作，使得代码更加简洁易读。Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），并且可以通过 then 方法进行链式调用。</p>
<p>Generator 是一种函数，可以通过 yield 关键字将函数的执行暂停，并在需要时恢复执行。Generator 可以用于处理异步操作，但需要手动编写控制流程，代码可读性较差。</p>
<p>Async 是一种异步编程的语法糖，它基于 Generator 和 Promise 实现，使得异步代码的编写更加简单明了。Async 函数使用 async 关键字声明，内部可以使用 await 关键字等待 Promise 对象的返回值，从而实现异步操作的同步化。</p>
<p>它们之间的关系是：Async 函数是 Generator 函数的语法糖，内部使用 Promise 对象实现异步操作。Promise 和 Generator 可以结合使用，通过 yield 关键字等待 Promise 对象的返回值，从而实现异步操作的同步化。</p>
<p>它们的优缺点和适用性如下：</p>
<p>Promise 的优点是代码简洁易读，缺点是需要手动编写控制流程，代码可读性较差。适用于需要处理多个异步操作的场景。</p>
<p>Generator 的优点是可以将异步操作同步化，缺点是需要手动编写控制流程，代码可读性较差。适用于需要处理复杂异步操作的场景。</p>
<p>Async 的优点是代码简洁易读，缺点是需要使用 Promise 对象实现异步操作，有一定的学习成本。适用于需要处理多个异步操作的场景，且代码可读性要求较高的场景。</p>
<h3 id="81、JS-中-string-的-startwith-和-indexof-两种方法的区别"><a href="#81、JS-中-string-的-startwith-和-indexof-两种方法的区别" class="headerlink" title="81、JS 中 string 的 startwith 和 indexof 两种方法的区别"></a>81、JS 中 string 的 startwith 和 indexof 两种方法的区别</h3><p>startsWith 方法用于判断一个字符串是否以指定的字符串开头，返回布尔值 true 或 false。它接受两个参数，第一个参数是要匹配的字符串，第二个参数是可选的，表示从哪个位置开始匹配。</p>
<p>indexOf 方法用于返回一个字符串在另一个字符串中第一次出现的位置，如果没有找到则返回 -1。它也接受两个参数，第一个参数是要查找的字符串，第二个参数是可选的，表示从哪个位置开始查找。</p>
<p>两者的区别在于 startsWith 方法只能判断字符串是否以指定字符串开头，而 indexOf 方法可以查找字符串在另一个字符串中的任意位置。另外，startsWith 方法的第二个参数表示从哪个位置开始匹配，而 indexOf 方法的第二个参数表示从哪个位置开始查找。</p>
<h3 id="82、JS-字符串转数字的方法"><a href="#82、JS-字符串转数字的方法" class="headerlink" title="82、JS 字符串转数字的方法"></a>82、JS 字符串转数字的方法</h3><p>在 JavaScript 中，字符串转数字的方法有多种，其中比较常用的包括 parseInt、parseFloat 和 Number。</p>
<ol>
<li><p>parseInt：将字符串转为整数。它的语法为 parseInt(string, radix)，其中 string 表示要转换的字符串，radix 表示转换的基数，即进制数。如果省略 radix 参数，则默认按十进制进行转换。parseInt 方法会忽略字符串前面的空格，并从第一个非空字符开始转换，直到遇到非数字字符为止。如果第一个字符不是数字或正负号，则返回 NaN。parseInt 方法还可以用于将二进制、八进制和十六进制字符串转换为十进制数。</p>
</li>
<li><p>parseFloat：将字符串转为浮点数。它的语法为 parseFloat(string)，其中 string 表示要转换的字符串。parseFloat 方法会忽略字符串前面的空格，并从第一个非空字符开始转换，直到遇到非数字字符为止。如果第一个字符不是数字或正负号，则返回 NaN。parseFloat 方法只能用于将十进制字符串转换为浮点数。</p>
</li>
<li><p>Number：将字符串转为数字。它的语法为 Number(string)，其中 string 表示要转换的字符串。Number 方法会忽略字符串前面和后面的空格，并从第一个非空字符开始转换，直到遇到非数字字符为止。如果第一个字符不是数字或正负号，则返回 NaN。Number 方法还可以用于将 true 和 false 转换为 1 和 0，将 null 转换为 0，将 undefined 转换为 NaN。</p>
</li>
</ol>
<p>这三种方法的区别在于，parseInt 和 parseFloat 只能用于将字符串转换为数字，而 Number 方法可以将其他类型的值转换为数字。另外，parseInt 和 parseFloat 可以指定进制数进行转换，而 Number 只能将字符串转换为十进制数。在实际应用中，需要根据具体的需求选择合适的方法进行转换。</p>
<h3 id="83、平时是怎么调试JS-的"><a href="#83、平时是怎么调试JS-的" class="headerlink" title="83、平时是怎么调试JS 的"></a>83、平时是怎么调试JS 的</h3><p>在开发中，我们可以使用浏览器自带的调试工具来调试 JavaScript 代码，比如 Chrome 的开发者工具、Firefox 的 Firebug 等。这些工具可以帮助我们查看代码执行过程中的变量值、调用栈、网络请求等信息，以及进行代码断点调试、单步执行等操作。</p>
<p>除了浏览器自带的调试工具，还有一些第三方调试工具，比如 VS Code 的调试插件、WebStorm 等 IDE 工具，它们提供了更加强大的调试功能，可以在本地调试、远程调试等场景下使用。</p>
<p>另外，console 调试也是一种常用的调试方式，我们可以在代码中使用 console.log()、console.error()、console.warn() 等方法输出调试信息，帮助我们快速定位问题。</p>
<p>在实际开发中，我们可以结合以上多种调试方式，根据具体情况选择合适的调试工具和方法，快速定位和解决问题。同时，我们还可以使用一些调试技巧，比如利用断言、利用代码注释、利用代码重构等方式，提高调试效率和代码质量。</p>
<h3 id="84、-怎么获得对象上的属性"><a href="#84、-怎么获得对象上的属性" class="headerlink" title="84、 怎么获得对象上的属性"></a>84、 怎么获得对象上的属性</h3><p>获取 JavaScript 对象上的属性可以使用点操作符或方括号操作符。点操作符适用于属性名是一个合法的标识符的情况，而方括号操作符适用于属性名是一个字符串或表达式的情况。</p>
<p>例如，假设有一个对象 person，它有一个 name 属性，可以使用以下两种方式获取该属性的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用点操作符 </span></span><br><span class="line"><span class="keyword">const</span> name = person.<span class="property">name</span>; </span><br><span class="line"><span class="comment">// 使用方括号操作符 </span></span><br><span class="line"><span class="keyword">const</span> name = person[<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果使用方括号操作符获取属性值，属性名必须是一个字符串或可以转换为字符串的表达式。此外，如果属性名中包含特殊字符，如空格或连字符，也必须使用方括号操作符获取属性值。</p>
<h3 id="85、async-和-await-具体该怎么用"><a href="#85、async-和-await-具体该怎么用" class="headerlink" title="85、async 和 await 具体该怎么用?"></a>85、async 和 await 具体该怎么用?</h3><p>async/await 是 ECMAScript 2017 中新增的语法，用于简化异步操作的代码。async/await 基于 Promise 实现，可以让异步代码看起来像同步代码，提高代码的可读性和可维护性。</p>
<p>async/await 的基本语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">someAsyncOperation</span>();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，async 表示该函数是一个异步函数，返回一个 Promise 对象；await 表示等待异步操作完成，可以在异步操作完成后获取其返回值。</p>
<p>async/await 的使用场景包括：</p>
<ol>
<li>异步操作需要按照一定顺序执行，例如需要先获取用户信息，再根据用户信息获取其他数据。</li>
<li>需要处理异步操作的错误，例如需要捕获异步操作中的异常并进行处理。</li>
<li>需要等待多个异步操作完成后再进行下一步操作，例如需要等待多个接口数据返回后再进行页面渲染。</li>
</ol>
<p>async/await 的优点包括：</p>
<ol>
<li>简化异步代码的编写，让异步代码看起来像同步代码，提高代码的可读性和可维护性。</li>
<li>可以使用 try/catch 捕获异步操作中的异常，方便错误处理。</li>
<li>可以使用 Promise.all 等方法等待多个异步操作完成后再进行下一步操作。</li>
</ol>
<p>async/await 的缺点包括：</p>
<ol>
<li>不能在顶层作用域中使用，必须在异步函数中使用。</li>
<li>不能直接处理回调函数，需要将回调函数封装成 Promise 对象后再使用 async/await。</li>
</ol>
<p>在实际开发中，可以使用 async/await 来简化异步操作的代码，提高代码的可读性和可维护性。同时，需要注意避免出现死循环等问题，以及合理处理异步操作中的错误。</p>
<h3 id="86、知道哪些-ES6，ES7-的语法"><a href="#86、知道哪些-ES6，ES7-的语法" class="headerlink" title="86、知道哪些 ES6，ES7 的语法"></a>86、知道哪些 ES6，ES7 的语法</h3><p>ES6 和 ES7 中的一些常用语法包括：</p>
<ol>
<li><p>let/const：用于声明变量和常量，相比于 var，let/const 具有块级作用域，可以避免变量提升和全局污染等问题。</p>
</li>
<li><p>箭头函数：用于声明匿名函数，可以简化函数的书写，同时具有词法作用域和 this 绑定的特点。</p>
</li>
<li><p>模板字符串：用于声明字符串，可以使用变量和表达式，同时支持换行和多行字符串的书写。</p>
</li>
<li><p>解构赋值：用于从对象或数组中提取值，可以方便地获取需要的数据，同时可以避免冗长的代码。</p>
</li>
<li><p>Promise：用于处理异步操作，可以避免回调地狱和提高代码的可读性和可维护性。</p>
</li>
<li><p>async/await：用于处理异步操作，可以使用同步的方式书写异步代码，同时可以避免回调地狱和提高代码的可读性和可维护性。</p>
</li>
</ol>
<p>这些语法的优点包括：</p>
<ol>
<li><p>let/const 可以避免变量提升和全局污染等问题，提高代码的可维护性。</p>
</li>
<li><p>箭头函数可以简化函数的书写，同时具有词法作用域和 this 绑定的特点，提高代码的可读性和可维护性。</p>
</li>
<li><p>模板字符串可以使用变量和表达式，同时支持换行和多行字符串的书写，提高代码的可读性和可维护性。</p>
</li>
<li><p>解构赋值可以方便地获取需要的数据，同时可以避免冗长的代码，提高代码的可读性和可维护性。</p>
</li>
<li><p>Promise 和 async/await 可以避免回调地狱，提高代码的可读性和可维护性。</p>
</li>
</ol>
<p>这些语法的适用场景包括：</p>
<ol>
<li><p>let/const 可以用于任何需要声明变量或常量的场景。</p>
</li>
<li><p>箭头函数可以用于任何需要声明函数的场景，特别是需要使用词法作用域和 this 绑定的场景。</p>
</li>
<li><p>模板字符串可以用于任何需要声明字符串的场景，特别是需要使用变量和表达式的场景。</p>
</li>
<li><p>解构赋值可以用于任何需要从对象或数组中提取值的场景，特别是需要获取多个值的场景。</p>
</li>
<li><p>Promise 和 async/await 可以用于任何需要处理异步操作的场景，特别是需要避免回调地狱和提高代码可读性和可维护性的场景。</p>
</li>
</ol>
<h3 id="87、promise-和-await-async-的关系"><a href="#87、promise-和-await-async-的关系" class="headerlink" title="87、promise 和 await/async 的关系"></a>87、promise 和 await/async 的关系</h3><p>Promise 和 async/await 都是 JavaScript 中用于处理异步操作的方法。</p>
<p>Promise 是 ES6 中引入的一种处理异步操作的方式，它可以将异步操作封装成一个 Promise 对象，通过 then 方法来处理异步操作的结果。Promise 的优点是可以避免回调地狱，使代码更加清晰易懂，但是在处理复杂的异步操作时，仍然需要嵌套多个 then 方法，代码可读性不高。</p>
<p>async/await 是 ES7 中引入的一种处理异步操作的方式，它基于 Promise，可以更加方便地处理异步操作。async 函数返回一个 Promise 对象，await 关键字可以暂停 async 函数的执行，等待 Promise 对象的状态改变后再继续执行。async/await 的优点是代码结构清晰，可读性强，可以避免回调地狱，但是需要注意错误处理，避免出现未捕获的异常。</p>
<p>在实际开发中，可以根据具体情况选择使用 Promise 或 async/await。对于简单的异步操作，可以使用 Promise，对于复杂的异步操作，可以使用 async/await 来提高代码的可读性和可维护性。同时，需要注意错误处理，避免出现未捕获的异常。</p>
<h3 id="88、JS-加载过程阻塞，解决方法"><a href="#88、JS-加载过程阻塞，解决方法" class="headerlink" title="88、JS 加载过程阻塞，解决方法"></a>88、JS 加载过程阻塞，解决方法</h3><p>JavaScript 加载过程阻塞是指在浏览器解析 HTML 文档时，如果遇到 script 标签，会立即停止 HTML 文档的解析，转而加载和执行 JavaScript 代码，这会导致页面加载速度变慢，影响用户体验。</p>
<p>解决方法包括：</p>
<ol>
<li><p>异步加载：将 JavaScript 代码放在异步加载的脚本中，例如使用动态创建 script 标签或者使用 XMLHttpRequest 对象加载 JavaScript 代码。</p>
</li>
<li><p>defer 属性：将 script 标签的 defer 属性设置为 true，表示该脚本会在 HTML 文档解析完毕后再执行，不会阻塞 HTML 文档的解析。</p>
</li>
<li><p>async 属性：将 script 标签的 async 属性设置为 true，表示该脚本会在加载完成后立即执行，不会阻塞 HTML 文档的解析，但是执行顺序不确定。</p>
</li>
<li><p>代码优化：将 JavaScript 代码进行优化，例如压缩、合并、减少全局变量等，可以减少 JavaScript 代码的大小和执行时间，提高页面加载速度。</p>
</li>
</ol>
<p>在实际开发中，可以根据具体情况选择适合的解决方法，例如对于需要立即执行的 JavaScript 代码，可以使用 async 属性，对于需要在页面加载完毕后执行的 JavaScript 代码，可以使用 defer 属性。同时，可以通过代码优化来减少 JavaScript 代码的大小和执行时间，提高页面加载速度和用户体验。</p>
<h3 id="89、JS-对象类型，基本对象类型以及引用对象类型的区别"><a href="#89、JS-对象类型，基本对象类型以及引用对象类型的区别" class="headerlink" title="89、JS 对象类型，基本对象类型以及引用对象类型的区别"></a>89、JS 对象类型，基本对象类型以及引用对象类型的区别</h3><p>在 JavaScript 中，对象类型分为基本对象类型和引用对象类型。基本对象类型包括字符串、数字、布尔值、null 和 undefined，它们是不可变的，即一旦创建就无法修改。而引用对象类型包括对象、数组和函数等，它们是可变的，即可以添加、删除或修改属性和方法。</p>
<p>基本对象类型是按值传递的，即在将一个变量赋值给另一个变量时，会创建一个新的值，两个变量互不影响。而引用对象类型是按引用传递的，即在将一个变量赋值给另一个变量时，两个变量指向同一个对象，修改其中一个变量的属性或方法会影响另一个变量。</p>
<p>了解这些区别可以帮助我们更好地理解 JavaScript 中的数据类型和变量传递方式，从而编写更加高效和可靠的代码。</p>
<h3 id="90、轮播的实现原理-假如一个页面上有两个轮播，你会怎么实现"><a href="#90、轮播的实现原理-假如一个页面上有两个轮播，你会怎么实现" class="headerlink" title="90、轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?"></a>90、轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?</h3><p>轮播的实现原理是通过定时器或者动画实现图片或者内容的循环播放。一般来说，轮播可以通过 JavaScript 或者 CSS 实现。</p>
<p>如果一个页面上有两个轮播，可以通过以下几种方式实现：</p>
<ol>
<li><p>使用不同的类名或者 ID 区分不同的轮播，然后分别编写对应的 JavaScript 代码实现。</p>
</li>
<li><p>将轮播封装成一个组件，通过传递不同的参数来区分不同的轮播，然后在页面中引用不同的组件实现。</p>
</li>
<li><p>使用现成的轮播插件，通过配置不同的参数来实现不同的轮播效果。</p>
</li>
</ol>
<h3 id="91、解释一下JS-的事件循环"><a href="#91、解释一下JS-的事件循环" class="headerlink" title="91、解释一下JS 的事件循环"></a>91、解释一下JS 的事件循环</h3><p>JS 的事件循环是指 JS 引擎在执行代码时，会将任务分为两种：同步任务和异步任务。同步任务会在主线程上按照顺序执行，而异步任务则会被放入任务队列中等待执行。当主线程上的同步任务执行完毕后，JS 引擎会不断地从任务队列中取出异步任务并执行，这个过程就是事件循环。</p>
<p>事件循环的实现依赖于浏览器或 Node.js 环境提供的事件模型。在浏览器中，事件循环通常由浏览器提供的 Web API 和事件队列实现，而在 Node.js 中则是由 libuv 库提供的事件循环机制实现。</p>
<h3 id="92、Localstorage、sessionStorage、-cookie-的区别"><a href="#92、Localstorage、sessionStorage、-cookie-的区别" class="headerlink" title="92、Localstorage、sessionStorage、 cookie 的区别"></a>92、Localstorage、sessionStorage、 cookie 的区别</h3><p>Localstorage、sessionStorage、cookie 都是用于在浏览器端存储数据的方式，它们之间的区别如下：</p>
<ol>
<li><p>存储大小：cookie 的大小限制为 4KB，而 Localstorage 和 sessionStorage 的大小限制在 5MB 左右。</p>
</li>
<li><p>有效期：cookie 可以设置过期时间，而 Localstorage 和 sessionStorage 没有过期时间，除非手动清除。</p>
</li>
<li><p>存储位置：cookie 和 sessionStorage 存储在浏览器内存中，而 Localstorage 存储在硬盘上。</p>
</li>
<li><p>作用域：cookie 的作用域可以是整个域名下的所有页面，而 Localstorage 和 sessionStorage 只在当前页面有效。</p>
</li>
<li><p>与服务器的通信：cookie 在每次请求时都会发送到服务器端，而 Localstorage 和 sessionStorage 不会。</p>
</li>
</ol>
<p>在实际开发中，可以根据具体需求选择合适的存储方式。如果需要在客户端和服务器端之间传递数据，可以使用 cookie；如果需要在同一页面内共享数据，可以使用 Localstorage 或 sessionStorage。</p>
<h3 id="93、解释一下-HTML5-Drag-API"><a href="#93、解释一下-HTML5-Drag-API" class="headerlink" title="93、解释一下 HTML5 Drag API"></a>93、解释一下 HTML5 Drag API</h3><p>HTML5 Drag API 是一组用于实现拖放操作的浏览器 API。它允许用户通过鼠标或触摸屏幕将元素从一个位置拖动到另一个位置。通过使用 Drag API，开发人员可以创建自定义的拖放操作，例如拖动文件到 Web 应用程序中进行上传。Drag API 包括三个主要事件：dragstart、dragover 和 drop。其中，dragstart 事件在开始拖动元素时触发，dragover 事件在拖动元素时触发，drop 事件在元素被拖放到目标区域时触发。开发人员可以使用这些事件来实现自定义的拖放操作。</p>
<h3 id="94-、解释一下-webworker"><a href="#94-、解释一下-webworker" class="headerlink" title="94 、解释一下 webworker"></a>94 、解释一下 webworker</h3><p>Web Worker 是 HTML5 标准中提供的一种 JavaScript 多线程解决方案，可以在后台线程中运行 JavaScript 脚本，不会影响页面的性能和响应速度。Web Worker 可以通过 postMessage() 方法与主线程进行通信，实现数据的传输和共享。Web Worker 适用于一些计算密集型、耗时长的任务，如图像处理、音视频编解码等。但是，Web Worker 无法访问 DOM，也不能与主线程共享同一份内存，需要通过消息传递来实现数据的共享。</p>
<h3 id="95、-和-的-valueOf-和-toString-的结果是什么"><a href="#95、-和-的-valueOf-和-toString-的结果是什么" class="headerlink" title="95、{}和[]的 valueOf 和 toString 的结果是什么?"></a>95、{}和[]的 valueOf 和 toString 的结果是什么?</h3><p>{} 的 valueOf 和 toString 方法返回的都是 “[object Object]”，因为 {} 是一个对象，而对象的默认 toString 方法返回的就是 “[object Object]”。</p>
<p>[] 的 valueOf 方法返回的是空数组本身，而 toString 方法返回的是以逗号分隔的数组元素的字符串形式，例如 [1, 2, 3].toString() 的结果是 “1,2,3”。</p>
<h3 id="96、三种事件模型是什么"><a href="#96、三种事件模型是什么" class="headerlink" title="96、三种事件模型是什么?"></a>96、三种事件模型是什么?</h3><ol>
<li><p>冒泡型事件模型（Bubbling Event Model）：事件从最具体的元素开始触发，逐级向上传播到较为不具体的节点。</p>
</li>
<li><p>捕获型事件模型（Capturing Event Model）：事件从最不具体的节点开始触发，逐级向下传播到较为具体的节点。</p>
</li>
<li><p>DOM 标准事件模型（DOM Standard Event Model）：事件分为捕获阶段、目标阶段和冒泡阶段三个阶段，先进行捕获，然后到达目标元素，最后冒泡回去。</p>
</li>
</ol>
<h3 id="97、介绍一下-V8-隐藏类"><a href="#97、介绍一下-V8-隐藏类" class="headerlink" title="97、介绍一下 V8 隐藏类"></a>97、介绍一下 V8 隐藏类</h3><p>V8 引擎使用隐藏类来提高 JavaScript 对象的访问速度。隐藏类是一种将属性名映射到内部属性偏移量的数据结构，它定义了对象的属性布局。当对象的属性发生变化时，V8 引擎会创建新的隐藏类。如果两个对象具有相同的属性和属性顺序，则它们将共享相同的隐藏类。这种优化可以显著提高 JavaScript 对象的访问速度，特别是在处理大量对象时。</p>
<h3 id="98、AMD-和-CMD-规范的区别-说一下-CommonJS、AMD-和-CMD"><a href="#98、AMD-和-CMD-规范的区别-说一下-CommonJS、AMD-和-CMD" class="headerlink" title="98、AMD 和 CMD 规范的区别? 说一下 CommonJS、AMD 和 CMD?"></a>98、AMD 和 CMD 规范的区别? 说一下 CommonJS、AMD 和 CMD?</h3><p>AMD 和 CMD 规范是 JavaScript 模块化的两种方案。AMD 是 Asynchronous Module Definition（异步模块定义）的缩写，CMD 是 Common Module Definition（通用模块定义）的缩写。</p>
<p>CommonJS 是 Node.js 采用的模块化规范，它的特点是同步加载模块。在 Node.js 中，每个文件都被视为一个模块，每个模块内部的变量都是局部的，不会污染全局作用域。</p>
<p>AMD 和 CMD 都是浏览器端的模块化规范，它们的特点是异步加载模块。AMD 规范先定义所有模块的依赖，然后异步加载这些依赖，最后执行回调函数。CMD 规范则是在需要使用某个模块时再去加载它。</p>
<p>在使用 AMD 规范时，需要使用 require.js 这样的库来实现模块的异步加载。而在使用 CMD 规范时，需要使用 sea.js 这样的库来实现模块的异步加载。</p>
<h3 id="99、谈谈-JS-的运行机制"><a href="#99、谈谈-JS-的运行机制" class="headerlink" title="99、谈谈 JS 的运行机制"></a>99、谈谈 JS 的运行机制</h3><p>JS 的运行机制主要包括以下几个方面：</p>
<ol>
<li>解析器将 JS 代码解析成抽象语法树（AST）。</li>
<li>将 AST 转换成字节码，然后再转换成机器码执行。</li>
<li>执行过程中，遇到异步任务会被挂起，等待异步任务完成后再继续执行。</li>
<li>JS 引擎使用垃圾回收器自动管理内存，当变量不再被引用时，垃圾回收器会自动回收其占用的内存空间。</li>
</ol>
<p>其中，第三个步骤是 JS 运行机制中比较重要的一部分，因为它涉及到了事件循环的概念。JS 引擎会将异步任务放入任务队列中，等待执行。当主线程执行完同步任务后，会不断地从任务队列中取出任务执行，直到任务队列为空。这个过程就是事件循环。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ZhuoRu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://webzhuoru.github.io/post/230702.html">https://webzhuoru.github.io/post/230702.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://webzhuoru.github.io" target="_blank">前端攻城狮ZhuoRu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web/">web</a></div><div class="post_share"><div class="social-share" data-image="/img/tab2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/./img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/./img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/./img/alipay.jpg" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/230703.html"><img class="prev-cover" data-lazy-src="/img/tab1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023面试题前端研发流程遇上chatGPT</div></div></a></div><div class="next-post pull-right"><a href="/post/230701.html"><img class="next-cover" data-lazy-src="/img/tab4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2023面试题前端框架遇上chatGPT</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/16106.html" title="填坑录"><img class="cover" data-lazy-src="/img/tab4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">填坑录</div></div></a></div><div><a href="/post/230703.html" title="2023面试题前端优化遇上chatGPT"><img class="cover" data-lazy-src="/img/tab5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">2023面试题前端优化遇上chatGPT</div></div></a></div><div><a href="/post/16107.html" title="Butterfly启动说明书"><img class="cover" data-lazy-src="/img/tab1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-27</div><div class="title">Butterfly启动说明书</div></div></a></div><div><a href="/post/17765.html" title="2月份面试题总结"><img class="cover" data-lazy-src="/img/tab3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-10</div><div class="title">2月份面试题总结</div></div></a></div><div><a href="/post/16199.html" title="2023面试题总结"><img class="cover" data-lazy-src="/img/tab4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">2023面试题总结</div></div></a></div><div><a href="/post/230701.html" title="2023面试题前端框架遇上chatGPT"><img class="cover" data-lazy-src="/img/tab4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">2023面试题前端框架遇上chatGPT</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://thirdqq.qlogo.cn/g?b=sdk&amp;nk=2276839311&amp;s=140" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ZhuoRu</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WebZhuoRu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/WebZhuoRu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2276839311@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://webzhuoru.github.io/" target="_blank" title="博客"><i class="fa-solid fa-book-skull"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2023%E7%89%88"><span class="toc-number">1.</span> <span class="toc-text">前端高频面试题 - 2023版</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-CSS"><span class="toc-number">1.1.</span> <span class="toc-text">HTML + CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-BFC-%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91-%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-margin%E2%80%9D%E5%A1%8C%E9%99%B7%E2%80%9D"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1 、什么是 BFC ?如何触发? 有何特点? 如何解决 margin”塌陷”?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81CSS-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%BA%A2%E5%87%BA-%E8%AF%B4%E4%B8%80%E4%B8%8B-overflow-%E4%B8%8D%E5%90%8C%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">2、CSS 如何处理溢出? 说一下 overflow 不同值的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">3、三栏布局有什么实现方式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81css-calc-%E5%B1%9E%E6%80%A7%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">4、css calc 属性作用是什么? 主要用于解决什么问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%AE%BDdiv%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">1.1.4.</span> <span class="toc-text">5、有一个固定长宽div，怎么实现在屏幕上垂直水平居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA-progressive-enhancement-%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7-graceful-degradation"><span class="toc-number">1.1.5.</span> <span class="toc-text">6、描述一下渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81iframe-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9-%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9-%E7%94%A8%E5%AE%83%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BF%87%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">7、iframe 有哪些优点? 哪些缺点? 用它来解决过什么问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Google-Chrome-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%A4%A7%E5%B0%8F%E5%B0%8F%E4%BA%8E-12px-%E7%9A%84%E6%96%87%E5%AD%97"><span class="toc-number">1.1.7.</span> <span class="toc-text">8、Google Chrome 如何支持大小小于 12px 的文字?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">9、描述一下 css 盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81HTML5%E7%9A%84%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.9.</span> <span class="toc-text">10、HTML5的特性有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81CSS3-%E7%9A%84%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.10.</span> <span class="toc-text">11、CSS3 的特性有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">1.1.11.</span> <span class="toc-text">12、如何实现水平居中?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">1.1.12.</span> <span class="toc-text">13、如何实现垂直居中?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80"><span class="toc-number">1.1.13.</span> <span class="toc-text">14、如何实现双圣杯布局?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81CSS%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.14.</span> <span class="toc-text">15、CSS中选择器的优先级?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81CSS-%E6%9D%83%E9%87%8D%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.15.</span> <span class="toc-text">16、CSS 权重如何计算?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81HTML5-input-%E5%85%83%E7%B4%A0-type-%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.16.</span> <span class="toc-text">17、HTML5 input 元素 type 属性有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81CSS-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-number">1.1.17.</span> <span class="toc-text">18、CSS 中哪些属性可继承，哪些不可以？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81CSS-%E5%8D%95%E4%BD%8D%E4%B8%AD-px%E3%80%81em-%E5%92%8C-rem-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%85%8D%E5%90%88-font-size-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.18.</span> <span class="toc-text">19、CSS 单位中 px、em 和 rem 的区别? 配合 font-size 如何计算? (移动端适配方案)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%9D%A1-0-5px-%E7%9A%84%E7%BA%BF%EF%BC%9F"><span class="toc-number">1.1.19.</span> <span class="toc-text">20、如何画一条 0.5px 的线？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E9%9A%90%E8%97%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95-display-none-%E4%B8%8E-visibility-hidden-%E4%B8%8E-opacity-0-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.20.</span> <span class="toc-text">21、隐藏一个元素有哪些方法? display: none 与 visibility: hidden 与 opacity: 0 之间的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81position-%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.21.</span> <span class="toc-text">22、position 的值有哪些，分别有什么特点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E5%8A%A8%EF%BC%8C%E6%B5%AE%E5%8A%A8%E4%BC%9A%E5%BC%95%E8%B5%B7%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%89%E4%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.22.</span> <span class="toc-text">23、什么是浮动，浮动会引起什么问题，有何解决方案?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81line-height-%E5%92%8C-height-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.23.</span> <span class="toc-text">24、line-height 和 height 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%EF%BC%8C%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E4%BC%9A%E5%A1%AB%E5%85%85%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.24.</span> <span class="toc-text">25、设置一个元素的背景颜色，背景颜色会填充哪些区域?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81inline-block%E3%80%81inline-%E5%92%8C-block-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%B8%BA%E4%BB%80%E4%B9%88-img-%E6%98%AF-inline-%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">26、inline-block、inline 和 block 的区别;为什么 img 是 inline 还可以设置宽高？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-%E5%A6%82%E4%BD%95%E8%AE%A9%E6%96%87%E6%A1%A3%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">27、什么是重绘? 什么是回流? 如何减少?如何让文档脱离文档流?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81box-sizing-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">28、box-sizing 的作用，如何使用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">29、如何实现清除浮动？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81css-%E5%8A%A8%E7%94%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">30、css 动画如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%B1%85%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">31、如何实现在某个容器中居中的布局？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AA-DOM-%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2"><span class="toc-number">1.2.6.</span> <span class="toc-text">32、如何改变一个 DOM 元素的字体颜色?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80%EF%BC%8Cposition-relative-%E5%92%8C-obsolute"><span class="toc-number">1.2.7.</span> <span class="toc-text">33、相对布局和绝对布局，position:relative 和 obsolute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90-flex-%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.8.</span> <span class="toc-text">34、什么是弹性盒子 flex 布局?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-rem-%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.9.</span> <span class="toc-text">35、什么是 rem 布局?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81less-%E5%92%8C-scss-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.10.</span> <span class="toc-text">36、less 和 scss 有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81-before-%E5%92%8C-after-%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">37、::before 和::after 中双冒号和单冒号的区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81CSS3-%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">38、CSS3 新增伪类，以及伪元素?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">39、响应式布局实现方案?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81link-%E6%A0%87%E7%AD%BE%E5%92%8C-import-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.3.</span> <span class="toc-text">40、link 标签和 import 标签的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81transition-%E5%92%8C-animation-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.</span> <span class="toc-text">41、transition 和 animation 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%85%83%E7%B4%A0%E3%80%81%E7%BD%AE%E6%8D%A2%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.5.</span> <span class="toc-text">42、说一下块元素、行元素、置换元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E5%A4%9A%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%87%E6%9C%AC%E7%9C%81%E7%95%A5%E5%8F%B7%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">43、多行元素的文本省略号如何实现?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81Doctype-%E4%BD%9C%E7%94%A8-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">44、Doctype 作用? 严格模式与混杂模式如何区分? 它们有何意义?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript"><span class="toc-number">1.4.</span> <span class="toc-text">Javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、javascript 的数据类型有哪些?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81javascript-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">2、javascript 有哪些引用类型?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">3、如何判断 javascript 的数据类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.3.</span> <span class="toc-text">4、怎么判断两个对象相等?如何判断空对象?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%810-1-0-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E-0-3-%E8%A7%A3%E9%87%8A%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">5、0.1 + 0.2 为什么不等于 0.3 ? (解释原理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%88%97%E4%B8%BE%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="toc-number">1.4.5.</span> <span class="toc-text">6、强制类型转换、隐式类型转换分别是什么，列举场景说明.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.6.</span> <span class="toc-text">7、创建函数的几种方式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.7.</span> <span class="toc-text">8、javascript 创建对象的几种方式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%88%97%E4%B8%BE%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1%E3%80%81%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%85%B6%E5%AE%9A%E4%B9%89%E3%80%82"><span class="toc-number">1.4.8.</span> <span class="toc-text">9、列举宿主对象、内置对象、原生对象并说明其定义。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.9.</span> <span class="toc-text">10、&#x3D;&#x3D;&#x3D;和 &#x3D;&#x3D;的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81null%EF%BC%8Cundefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.10.</span> <span class="toc-text">11、null，undefined 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%BF%94%E5%9B%9E-undefined-%E5%80%BC"><span class="toc-number">1.4.11.</span> <span class="toc-text">12、什么情况下会返回 undefined 值?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.12.</span> <span class="toc-text">13、如何区分数组和对象?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E9%99%8D%E7%BB%B4"><span class="toc-number">1.4.13.</span> <span class="toc-text">14、多维数组如何降维?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F-%E5%B9%B4-%E6%9C%88-%E6%97%A5-%E6%97%B6-%E5%88%86-%E7%A7%92"><span class="toc-number">1.4.14.</span> <span class="toc-text">15、怎么获取当前日期 (年-月-日 时:分:秒) ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E6%95%B0%E7%BB%84-%E4%BC%AA%E6%95%B0%E7%BB%84-%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%85%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">1.4.15.</span> <span class="toc-text">16、什么是类数组(伪数组)，如何将其转化为真实的数组？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.15.1.</span> <span class="toc-text">17、如何遍历对象的属性?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AA-onclick-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.16.</span> <span class="toc-text">18、如何给一个按钮绑定两个 onclick 事件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.17.</span> <span class="toc-text">19、变量提升是什么?与函数提升的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E5%A6%82%E4%BD%95%E5%BB%B6%E9%95%BF"><span class="toc-number">1.4.18.</span> <span class="toc-text">20、什么是作用域链?如何延长?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.19.</span> <span class="toc-text">21、如何实现数组的随机排序?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81dom-%E8%8A%82%E7%82%B9%E7%9A%84-Attribute-%E5%92%8C-Property-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.20.</span> <span class="toc-text">22、dom 节点的 Attribute 和 Property 有何区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81dom-%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.21.</span> <span class="toc-text">23、dom 结构操作怎样添加、移除、移动、复制、创建和查找节点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">1.4.22.</span> <span class="toc-text">24、什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.4.23.</span> <span class="toc-text">25、什么是事件捕获，它是如何工作的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BA%8B%E4%BB%B6%E5%85%88%E5%86%92%E6%B3%A1%E5%90%8E%E6%8D%95%E8%8E%B7"><span class="toc-number">1.4.24.</span> <span class="toc-text">26、如何让事件先冒泡后捕获?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81JavaScript-%E5%8A%A8%E7%94%BB%E5%92%8C-CSS3-%E5%8A%A8%E7%94%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.25.</span> <span class="toc-text">27、JavaScript 动画和 CSS3 动画有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81dom-%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.26.</span> <span class="toc-text">28、dom 的事件模型 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E4%BA%8B%E4%BB%B6%E4%B8%89%E8%A6%81%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.27.</span> <span class="toc-text">29、事件三要素是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.28.</span> <span class="toc-text">30、获取元素位置?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.29.</span> <span class="toc-text">31、如何绑定事件，如何解除事件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.30.</span> <span class="toc-text">32、对事件委托的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81setTimeout-%E5%92%8C-setInterval-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.31.</span> <span class="toc-text">33、setTimeout 和 setInterval 的区别及用法是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E7%94%A8-setTimeout-%E6%9D%A5%E5%AE%9E%E7%8E%B0-setInterval"><span class="toc-number">1.4.32.</span> <span class="toc-text">34、用 setTimeout 来实现 setInterval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E3%80%81document-write-%E5%92%8C-innerHTML-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.33.</span> <span class="toc-text">35 、document.write 和 innerHTML 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%85%83%E7%B4%A0%E6%8B%96%E5%8A%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7"><span class="toc-number">1.4.34.</span> <span class="toc-text">36.元素拖动如何实现，原理是怎样?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98-repaint-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81-reflow-%E5%A6%82%E4%BD%95%E6%9C%80%E5%B0%8F%E5%8C%96%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81"><span class="toc-number">1.4.35.</span> <span class="toc-text">37、什么是重绘(repaint)? 什么是回流(reflow)? 如何最小化重绘和回流?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.4.36.</span> <span class="toc-text">38、延迟加载的方式有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.37.</span> <span class="toc-text">39、垃圾回收机制有哪些? 具体怎么如何执行?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.4.38.</span> <span class="toc-text">40、什么是内存泄漏 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%8C%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95"><span class="toc-number">1.4.39.</span> <span class="toc-text">41、数组遍历的方法有哪些，分别有什么特点，性能如何 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81ES5-%E5%92%8C-ES6-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CES6-%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.40.</span> <span class="toc-text">42、ES5 和 ES6 的区别，ES6 新增了什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81ES6-%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C-ES5-%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.41.</span> <span class="toc-text">43、ES6 的继承和 ES5 的继承有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81var%E3%80%81let%E3%80%81const-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.42.</span> <span class="toc-text">44、var、let、const 之间的区别? 暂时性死区如何理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81Class%E3%80%81extends-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.43.</span> <span class="toc-text">45、Class、extends 是什么，有什么作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-JS-%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-number">1.4.44.</span> <span class="toc-text">46、什么是 JS 闭包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.45.</span> <span class="toc-text">47 、说一下类的创建和继承，列举一下你所知道的继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-%EF%BC%9F"><span class="toc-number">1.4.46.</span> <span class="toc-text">48、如何解决异步回调地狱 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.4.47.</span> <span class="toc-text">49、说一下图片的懒加载和预加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.48.</span> <span class="toc-text">50、mouseover 和 mouseenter 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E3%80%81new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">1.4.49.</span> <span class="toc-text">51 、new 操作符做了哪些事情？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E3%80%81-%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8-this-%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0-bind%EF%BC%8Capply%EF%BC%8Ccall-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%8C%E5%86%85%E5%9C%A8%E5%88%86%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.4.50.</span> <span class="toc-text">52、 改变函数内部 this 指针的指向函数 (bind，apply，call 的区别)，内在分别是如何实现的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E3%80%81JS-%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%EF%BC%8C%E6%AF%94%E5%A6%82-clientHeight-scrolHeight-offsetHeight-%E4%BB%A5%E5%8F%8A-scrolTop-offsetTop-clientTop-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.51.</span> <span class="toc-text">53、JS 的各种位置，比如 clientHeight, scrolHeight, offsetHeight ,以及 scrolTop, offsetTop, clientTop 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.52.</span> <span class="toc-text">54、异步加载JS的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E3%80%81Ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.53.</span> <span class="toc-text">55、Ajax 解决浏览器缓存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E3%80%81%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="toc-number">1.4.54.</span> <span class="toc-text">56、节流和防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E3%80%81eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">1.4.55.</span> <span class="toc-text">57、eval 是做什么的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.56.</span> <span class="toc-text">58 、对象深拷贝的简单实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E3%80%81%E5%AE%9E%E7%8E%B0-JS-%E4%B8%AD%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%EF%BC%8CDate-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.57.</span> <span class="toc-text">59、实现 JS 中所有对象的深度克隆 (包装对象，Date 对象，正则对象)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-once-%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1"><span class="toc-number">1.4.58.</span> <span class="toc-text">60、实现一个 once 函数，传入函数参数只执行一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E3%80%81%E5%B0%86%E5%8E%9F%E7%94%9F%E7%9A%84-ajax-%E5%B0%81%E8%A3%85%E6%88%90-promise"><span class="toc-number">1.4.59.</span> <span class="toc-text">61、将原生的 ajax 封装成 promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E3%80%81JS-%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">1.4.60.</span> <span class="toc-text">62、JS 监听对象属性的改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8-get-%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.61.</span> <span class="toc-text">63、如何实现一个私有变量，用 get 可以访问，不能直接访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E3%80%81%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%AE%8C%E5%90%8E%E5%86%8D%E5%8A%A0%E8%BD%BD%E4%B8%8B%E4%B8%80%E5%BC%A0"><span class="toc-number">1.4.62.</span> <span class="toc-text">64、怎么控制一次加载一张图片，加载完后再加载下一张</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8-JavaScript-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E4%BA%8E-sleep-%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%8C%E5%8D%B3%E6%9A%82%E5%81%9C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E5%90%8E%E7%BB%AD%E4%BB%A3%E7%A0%81%EF%BC%9F%E5%8F%AF%E4%BB%A5%E7%BB%99%E5%87%BA-ES5-%E6%88%96-ES6-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-number">1.4.63.</span> <span class="toc-text">65、如何在 JavaScript 中实现类似于 sleep 的效果，即暂停一段时间后再执行后续代码？可以给出 ES5 或 ES6 的实现方式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E3%80%81Function-proto-getPrototypeOf-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.64.</span> <span class="toc-text">66、Function.proto(getPrototypeOf)是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD-this-%E6%8C%87%E5%90%91"><span class="toc-number">1.4.65.</span> <span class="toc-text">67、箭头函数中 this 指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68%E3%80%81-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.4.66.</span> <span class="toc-text">68、 数组常用方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69%E3%80%81-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.67.</span> <span class="toc-text">69、 数组去重有哪些方法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E3%80%81%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.4.68.</span> <span class="toc-text">70、如何去除字符串首尾空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84-JS-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.69.</span> <span class="toc-text">71、说说你所知道的 JS 语言特性?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">1.4.70.</span> <span class="toc-text">72、如何判断一个变量是否为数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E3%80%81JS-%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.4.71.</span> <span class="toc-text">73、JS 的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.72.</span> <span class="toc-text">74、谈谈你所理解的跨域，为什么会有这个问题?如何解决?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75%E3%80%81null-undefined-%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88-null-undefined-%E5%91%A2"><span class="toc-number">1.4.73.</span> <span class="toc-text">75、null &#x3D;&#x3D; undefined 输出什么? null &#x3D;&#x3D;&#x3D; undefined 呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.4.74.</span> <span class="toc-text">76、什么是按需加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-symbol"><span class="toc-number">1.4.75.</span> <span class="toc-text">77、简单介绍一下 symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-promise%EF%BC%8C%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.76.</span> <span class="toc-text">78、介绍一下 promise，及其底层如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E3%80%81JS-%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%A1%B6%E7%AB%AF%E6%98%AF%E4%BB%80%E4%B9%88-0bject-%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-0bject-%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.77.</span> <span class="toc-text">79、JS 原型链，原型链的顶端是什么? 0bject 的原型是什么? 0bject 的原型的原型是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80%E3%80%81promise-Generator-Async-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.78.</span> <span class="toc-text">80、promise+Generator+Async 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81%E3%80%81JS-%E4%B8%AD-string-%E7%9A%84-startwith-%E5%92%8C-indexof-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.79.</span> <span class="toc-text">81、JS 中 string 的 startwith 和 indexof 两种方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82%E3%80%81JS-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.80.</span> <span class="toc-text">82、JS 字符串转数字的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83%E3%80%81%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95JS-%E7%9A%84"><span class="toc-number">1.4.81.</span> <span class="toc-text">83、平时是怎么调试JS 的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84%E3%80%81-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%BE%97%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.82.</span> <span class="toc-text">84、 怎么获得对象上的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85%E3%80%81async-%E5%92%8C-await-%E5%85%B7%E4%BD%93%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">1.4.83.</span> <span class="toc-text">85、async 和 await 具体该怎么用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86%E3%80%81%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B-ES6%EF%BC%8CES7-%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.84.</span> <span class="toc-text">86、知道哪些 ES6，ES7 的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87%E3%80%81promise-%E5%92%8C-await-async-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.85.</span> <span class="toc-text">87、promise 和 await&#x2F;async 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88%E3%80%81JS-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.86.</span> <span class="toc-text">88、JS 加载过程阻塞，解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89%E3%80%81JS-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.87.</span> <span class="toc-text">89、JS 对象类型，基本对象类型以及引用对象类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90%E3%80%81%E8%BD%AE%E6%92%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%81%87%E5%A6%82%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BD%AE%E6%92%AD%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.88.</span> <span class="toc-text">90、轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJS-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.89.</span> <span class="toc-text">91、解释一下JS 的事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92%E3%80%81Localstorage%E3%80%81sessionStorage%E3%80%81-cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.90.</span> <span class="toc-text">92、Localstorage、sessionStorage、 cookie 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-HTML5-Drag-API"><span class="toc-number">1.4.91.</span> <span class="toc-text">93、解释一下 HTML5 Drag API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-webworker"><span class="toc-number">1.4.92.</span> <span class="toc-text">94 、解释一下 webworker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95%E3%80%81-%E5%92%8C-%E7%9A%84-valueOf-%E5%92%8C-toString-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.93.</span> <span class="toc-text">95、{}和[]的 valueOf 和 toString 的结果是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96%E3%80%81%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.94.</span> <span class="toc-text">96、三种事件模型是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-V8-%E9%9A%90%E8%97%8F%E7%B1%BB"><span class="toc-number">1.4.95.</span> <span class="toc-text">97、介绍一下 V8 隐藏类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98%E3%80%81AMD-%E5%92%8C-CMD-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%B4%E4%B8%80%E4%B8%8B-CommonJS%E3%80%81AMD-%E5%92%8C-CMD"><span class="toc-number">1.4.96.</span> <span class="toc-text">98、AMD 和 CMD 规范的区别? 说一下 CommonJS、AMD 和 CMD?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99%E3%80%81%E8%B0%88%E8%B0%88-JS-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.97.</span> <span class="toc-text">99、谈谈 JS 的运行机制</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/230703.html" title="2023面试题前端优化遇上chatGPT"><img data-lazy-src="/img/tab5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023面试题前端优化遇上chatGPT"/></a><div class="content"><a class="title" href="/post/230703.html" title="2023面试题前端优化遇上chatGPT">2023面试题前端优化遇上chatGPT</a><time datetime="2023-07-16T16:15:21.029Z" title="发表于 2023-07-17 00:15:21">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/230703.html" title="2023面试题前端研发流程遇上chatGPT"><img data-lazy-src="/img/tab1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023面试题前端研发流程遇上chatGPT"/></a><div class="content"><a class="title" href="/post/230703.html" title="2023面试题前端研发流程遇上chatGPT">2023面试题前端研发流程遇上chatGPT</a><time datetime="2023-07-16T16:15:21.029Z" title="发表于 2023-07-17 00:15:21">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/230702.html" title="2023面试题前端三剑客遇上chatGPT"><img data-lazy-src="/img/tab2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023面试题前端三剑客遇上chatGPT"/></a><div class="content"><a class="title" href="/post/230702.html" title="2023面试题前端三剑客遇上chatGPT">2023面试题前端三剑客遇上chatGPT</a><time datetime="2023-07-16T16:15:20.585Z" title="发表于 2023-07-17 00:15:20">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/230701.html" title="2023面试题前端框架遇上chatGPT"><img data-lazy-src="/img/tab4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023面试题前端框架遇上chatGPT"/></a><div class="content"><a class="title" href="/post/230701.html" title="2023面试题前端框架遇上chatGPT">2023面试题前端框架遇上chatGPT</a><time datetime="2023-07-16T16:15:20.581Z" title="发表于 2023-07-17 00:15:20">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/17765.html" title="2月份面试题总结"><img data-lazy-src="/img/tab3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2月份面试题总结"/></a><div class="content"><a class="title" href="/post/17765.html" title="2月份面试题总结">2月份面试题总结</a><time datetime="2023-02-10T09:05:30.835Z" title="发表于 2023-02-10 17:05:30">2023-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/16199.html" title="2023面试题总结"><img data-lazy-src="/img/tab4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023面试题总结"/></a><div class="content"><a class="title" href="/post/16199.html" title="2023面试题总结">2023面试题总结</a><time datetime="2023-01-06T06:57:04.576Z" title="发表于 2023-01-06 14:57:04">2023-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/tab2.png')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By ZhuoRu</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://wechat-delta.vercel.app/',
      region: 'ap-guangzhou'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://wechat-delta.vercel.app/',
      region: 'ap-guangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas id="universe"></canvas><div class="aplayer no-destroy" data-id="7592292364" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-loop="all" data-lrctype="0"> </div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="./js/universe.js"></script><script defer src="./js/sun_moon.js"></script><script defer src="https://fastly.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer data-pjax src="/js/wow_init.js"></script><script defer src="https://fastly.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/1026.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/tab4.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/1026.html&quot;);" href="javascript:void(0);" alt="">Vue3学习总结</a><div class="blog-slider__text">前端内卷的开始,Vue3开发上手总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/1026.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/16107.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/tab1.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/16107.html&quot;);" href="javascript:void(0);" alt="">Butterfly启动说明书</a><div class="blog-slider__text">启动说明书</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/16107.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/1038.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/tab3.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/1038.html&quot;);" href="javascript:void(0);" alt="">css学习总结</a><div class="blog-slider__text">课程目标:1. 学会使用CSS选择器2. 熟记CSS样式和外观属性3. 熟练掌握CSS各种选择器4. 熟练掌握CSS各种选择器5. 熟练掌握CSS三种显示模式6. 熟练掌握CSS背景属性7. 熟练掌握CSS三大特性8. 熟练掌握CSS盒子模型9. 熟练掌握CSS浮动10.熟练掌握CSS定位11.熟练掌握CSS高级技巧强化CSS</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/1038.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/2020715.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/tab4.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/2020715.html&quot;);" href="javascript:void(0);" alt="">html学习总结</a><div class="blog-slider__text">学习目标:了解常用浏览器;掌握WEB标准;理解标签语义化;掌握常用的排版标签;掌握常用的文本格式化图像链接等标签;掌握三种列表标签;掌握表格标签;掌握表格标签;掌握表单标签</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/2020715.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>